---
title: "Analyzing the Role of Community and Individual Factors in LAMP Grant Funding: Identifying Diverse Barriers Across Clustered US Counties"
subtitle: "FAS Food Systems Impact Fellowship Capstone Project, April 2024"
author: "Elliot Hohn, Sr. Agricultural Data Scientist Impact Fellow"
execute:
  echo: false
  warning: false
format:
  html:
    theme: simplex
    fontsize: 1.1em
    linestretch: 1.7
    mainfont: avenir
    #page-layout: custom
fig-align: center
editor: visual
#server: shiny
---

## Introduction

### Local Agriculture Market Program (LAMP)

The USDA's Agricultural Marketing Service (AMS) administers a variety of grant programs aimed at strengthening local and regional food systems. The Local Agriculture Market Program (LAMP) is one such program that supports direct producer-to-consumer marketing, food enterprises, and value-added agricultural products. Established under the 2018 Farm Bill, LAMP fosters community collaboration and public-private partnerships to improve regional food economies, aiding in the development of business strategies and infrastructure for local food systems.

![Promotional materials for LAMP. Image: USDA-AMS, 2024](img/LAMP%20Twitter.png){fig-align="center"}

### Building community capital through food systems investment

#### Theory of Change

According to AMS, the main goals of the LAMP program include the following[^1]:

[^1]: <https://www.ams.usda.gov/services/grants/lamp>. Accessed April 20, 2024

-   Simplify the application processes and the reporting processes for the Program

-   Improve income and economic opportunities for producers and food businesses through job creation

-   Strengthen capacity and regional food system development through community collaboration and expansion of mid-tier value chains

#### Targeting / prioritizing funding

In 2021, AMS partnered with Florida A&M University and the University of Maryland Eastern Shore on a project focusing on the following goals[^2]:

[^2]: <https://www.ams.usda.gov/sites/default/files/media/MSDUSDAAMSGrantApplicantTASociallyDisadvantaged.pdf>

1.  Evaluate barriers to AMS grant opportunities for socially disadvantaged communities

2.  Invest in building trust and confidence between these communities and the USDA

3.  Take action to rectify inequalities in program access through targeted outreach, training, and technical assistance.

(something here about the history of discrimination in USDA programs, sowing mistrust among these communities, and potential hesitancy to partner with USDA on programs like LAMP.

### Goal of this project

-   Analyze the data to see if there are relationships between community characteristics and likelihood of receiving LAMP funding

-   Generate actionable insights into improving LAMP grant targeting, identify

### Caveats and such

-   Temporal component -

-   Does not include data on who applied, in addition to who was funded.

### Best practices, current innovation, and policy proposals

(Identify and discuss successful program and policy models, emerging and innovative approaches, or other proposed interventions relevant to the issue area.)

## Objectives of this research

## Methods

(TBD)

```{r environment setup}
#| include: false

library(tidyverse)
library(sf)
library(openxlsx)
library(corrplot)
library(NbClust)
library(broom)
library(caret)
library(tidycensus)
library(tidyUSDA)
library(FactoMineR)
library(factoextra)
library(leaflet)
library(units)
library(lmtest)
library(AER)
library(ggthemes)
library(shiny)
library(rmarkdown)
library(plotly)
library(reshape2)
library(bivariatechoropleths)
library(biscale)
library(rio)
library(janitor)
library(paletteer)
library(scales)
library(ggpubr)
library(ggcorrplot)
library(glue)
library(ggsci)

census_api_key(Sys.getenv("CENSUS_API_KEY"))
ag_census_api_key <- Sys.getenv("AG_CENSUS_API_KEY")

# reusable function for normalizing data
normalize <- function(x){
  round((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)), 4)
}

options(
  scipen = 999,
  dplyr.summarise.inform=FALSE
  )

my_crs <- 5070

my_map <- leaflet(options = leafletOptions(minZoom = 3)) %>%
  #addTiles() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  setMaxBounds(
    lng1 = -127.8,
    lat1 = 52.5,
    lng2 = -63.8,
    lat2 = 21.4)

subsetter <- function(topic) {
  d <- comm_wealth_all %>%
    filter(topic_area == topic) %>%
    select(fips, year, variable_name, value) %>%
    group_by(fips, variable_name) %>%
    summarise(value = mean(value, na.rm = TRUE)) %>%
    ungroup() %>%
    pivot_wider(names_from = variable_name, values_from = value)

  cols <- colnames(select_if(d, is.numeric))
  d <- d %>%
    mutate(
      across(all_of(cols), normalize))

  d$mean <- rowMeans(d[,cols], na.rm = TRUE)
  d$composite <- rescale(d$mean, to = c(0, 100))
  
  d <- counties %>%
    merge(d, by = 'fips') %>%
    st_transform(4326) %>%
    st_set_geometry('geometry') %>%
    select(-mean)

  return(d)
}

pca_prep <- function(d){
  rownames(d) <- d$GEOID
  d <- d %>%
    st_drop_geometry() %>%
    drop_na() %>%
    select(-c(GEOID, county_name, overall))
  return(d)
}

# pca_reduce <- function(d){
#   pca_results <- PCA(pca_prep(d), graph = FALSE)
#   eig_keepers <- data.frame(pca_results$eig) %>%
#     filter(eigenvalue >= 1.0)
#   comps <- nrow(eig_keepers)
#   if (comps > 0) {
#     scores <- pca_results$var$coord %>% as_tibble()
#     df_reduced <- scores[,1:comps]
#     colnames(df_reduced) <- paste(deparse(substitute(d)), colnames(df_reduced), sep = "_")
#     return(data.frame(df_reduced))
#   } else {
#     return(NULL)
#   }
# }
```

### Local Agriculture Market Program (LAMP)

The LAMP program's main goals[^3] are:

[^3]: <https://www.ams.usda.gov/services/grants/lamp>

-   Connect and cultivate regional food economies through public-private partnerships.

-   Support the development of business plans, feasibility studies, and strategies for value-added agricultural production and local and regional food system infrastructure.

-   Strengthen capacity and regional food system development through community collaboration and expansion of mid-tier value chains.

-   Improve income and economic opportunities for producers and food businesses through job creation; and

-   Simplify the application processes and the reporting processes for the Program.

The major grant programs within LAMP include the [Local Food Promotion Program (LFPP)](https://www.ams.usda.gov/services/grants/lfpp), [Regional Food Systems Partnership (RFSP)](https://www.ams.usda.gov/services/grants/rfsp), and the [Farmers Market Promotion Program (FMPP)](https://www.ams.usda.gov/services/grants/fmpp).

```{r load lamp and join data}
#| output: false

# Data downloaded directly from URL on the LAMP Navigator webpage
lamp_url <- 'https://www.ams.usda.gov/sites/default/files/media/LAMPDatasetandDataDictionary.xlsx'
lamp <- read.xlsx(lamp_url, sheet = 'LAMP Dataset 2006 to 2023') %>%
  rename(
    state = State,
    city = City.2
    ) %>%
  mutate(city = str_squish(str_trim(tolower(city)))) %>%
  filter(!state %in% c('HI', 'AK', 'PR'))

# Load US Cities dataset from github
url <- 'https://raw.githubusercontent.com/kelvins/US-Cities-Database/main/csv/us_cities.csv'
city_loc <- read.csv(url) %>%
  select(-c(ID, COUNTY)) %>%
  rename(
    city = CITY,
    state = STATE_CODE
  ) %>%
  mutate(city = str_squish(str_trim(tolower(city)))) %>%
  group_by(city, state) %>%
  filter(row_number()==1) %>% 
  ungroup()

# do the join
lamp <- merge(lamp, city_loc, by = c('city', 'state'), all.x = TRUE)

# convert to sf object
lamp_sf <- lamp %>% 
  drop_na(LATITUDE, LONGITUDE) %>%
  st_as_sf(coords = c("LONGITUDE", "LATITUDE")) %>%
  st_set_crs(4326) %>%
  st_transform(4326)

# Load counties data (downloaded somewhere on the interwebs...)
counties <- st_read('data/cb_2021_us_county_20m/cb_2021_us_county_20m.shp') %>%
  filter(!STATE_NAME %in% c('Alaska', 'Hawaii', 'Puerto Rico')) %>%
  rename(
    county_name = NAMELSAD,
    fips = GEOID
    ) %>%
  select(fips, county_name, geometry) %>%
  #st_set_crs(4326) %>%
  st_transform(4326)

# spatial join points within counties
lamp_by_county <- counties %>%
  st_join(lamp_sf, join = st_contains, left = TRUE) %>%
  group_by(fips) %>%
  mutate(total_grant = sum(Award.Amount)) %>%
  mutate(lamp_funded = as.factor(ifelse(is.na(Award.Amount) | Award.Amount == 0, 0, 1))) %>%
  #rename(County = NAMELSAD) %>%
  select(fips, county_name, lamp_funded, Award.Amount)
```

##### Distribution of LAMP Grant funding across CONUS

```{r lamp funded leaflet map}

d_map_lamp <- lamp_sf
d_map_lamp$point_size <- scales::rescale(d_map_lamp$Award.Amount, c(1, 15))

grant_colors <- as.vector(paletteer_d("nbapalettes::thunder")[1:3])
pal <- colorFactor(
  palette = grant_colors, domain = d_map_lamp$Grant.Type)

labels <- sprintf(
  "<strong>%s</strong><br/>Year: %g<br/>Award amount: %s<br/>Grant type: %s<br/>Project type: %s",
  d_map_lamp$Organization, d_map_lamp$Year, scales::dollar(d_map_lamp$Award.Amount),
  d_map_lamp$Grant.Type, d_map_lamp$Project.Type
) %>% lapply(htmltools::HTML)

my_map %>%
  addCircleMarkers(
    data = d_map_lamp,
    radius = ~ point_size,
    color = ~pal(Grant.Type),
    stroke = FALSE,
    fillOpacity = 0.5,
    label = labels,
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto")
 ) %>%
  addLegend(
    data = d_map_lamp, "bottomright", pal = pal, values = ~Grant.Type,
    title = "Grant Type",
    opacity = 1
  ) %>%
  bslib::card(full_screen = TRUE)
```

## Community characteristics

Participation in grant programs supporting investment in local food systems, such as LAMP, is influenced by a variety of socioeconomic and environmental factors that influence local needs, as well as local capacity to apply for grants and manage funded projects. Community wealth, which encompasses social capital, natural capital, financial capital, and a variety of other forms of wealth impacts the ability to engage and participate in such programs.[^4] Moreover, things like poverty and food insecurity rates have been shown to exacerbate vulnerabilities and influence accessibility and participation in programs.[^5] With food systems-focused programs such as LAMP, urbanization and proximity to agricultural land can influence market dynamics and food system connectivity.[^6]

[^4]: Flora, Cornelia Butler, Jan L. Flora, and Stephen P. Gasteyer. *Rural Communities: Legacy and Change*. 4th ed. Routledge, 2018. <https://doi.org/10.4324/9780429494697>.

[^5]: Alisha Coleman-Jensen, Matthew P. Rabbitt, Christian A. Gregory, and Anita Singh. 2021. Household Food Security in the United States in 2020, ERR-298, U.S. Department of Agriculture, Economic Research Service.

[^6]: Pothukuchi, Kameshwari, and Jerome L. Kaufman. “The Food System: A Stranger to the Planning Field.” *Journal of the American Planning Association* 66, no. 2 (June 30, 2000): 113–24. <https://doi.org/10.1080/01944360008976093>.

This report will assess the relationship of each of these community characteristics to the distribution of LAMP grants across the US.

### Exploration of available data

As a first step, a variety of data sets were obtained, cleaned, and used for some general data exploration.

#### Indicators of community wealth

```{r prep comm wealth data}

## Community Wealth
comm_wealth_url <- 'https://raw.githubusercontent.com/CSU-Local-and-Regional-Food-Systems/USDA-AMS-Data-and-Metrics/main/Indicators%20of%20Community%20Wealth/community_wealth.csv'
comm_wealth_all <- read.csv(comm_wealth_url) %>%
  filter(fips > 100) # remove national level rows

# Function to add leading 0 to 4-digit fips values in comm_wealth to facilitate later joins
add_leading_zero <- function(x) {
  # Check if the number has 4 digits
  ifelse(nchar(x) == 4, paste0("0", x), x)
}

# apply funcion to fips column
comm_wealth_all$fips <- sapply(comm_wealth_all$fips, add_leading_zero)
```

```{r wealth data subset}
#| warnings: false

infrastructure <- subsetter("Infrastructure") %>%
  select(-broad_11)
food_processors <- subsetter("Food Processors")
community_resources <- subsetter("Community Resources")
population <- subsetter("Population")
financial <- subsetter("Financial")
food_insecurity <- subsetter("Food Insecurity")
natural <- subsetter("Natural")
agriculture <- subsetter("Agriculture")
```

##### Exploratory map of community wealth data

```{r wealth map}
#| warnings: false

bins <- seq(from = 0, to = 1, by = 0.2)
pal <- colorBin("YlOrRd", domain = 0:1, bins = bins)

pal_generator <- function(d, pal = 'RdPu') {
  return(colorQuantile(palette = pal, domain = d$overall, n = 6, na.color = 'grey75'))
}

label_generator <- function(d) {
  d_name <- deparse(substitute(d))
  label <- paste0("<strong>{", d_name, "$county_name}</strong>")
  for (i in 4:ncol(d)-1) {
    label <- paste0(label,'<br/>', colnames(d)[i], ': {', d_name, '$', colnames(d)[i], "}")
  }
  return(
    glue(label) %>% lapply(htmltools::HTML)
  )
}

my_map %>%
  addPolygons(
    data = natural,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      natural, 
      as.vector(paletteer_d("MetBrewer::Hokusai2")))(natural$composite),
    group = "Natural_Resources",
    popup = label_generator(natural),
    popupOptions = popupOptions(
      #keepInView = TRUE,
      closeOnClick = TRUE
    )
  ) %>%
  addPolygons(
    data = agriculture,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      agriculture,
      as.vector(paletteer_d("MetBrewer::VanGogh3"))
      )(agriculture$composite),
    group = "Agricultural_Resources",
    popup = label_generator(agriculture)
    ) %>%
  addPolygons(
    data = financial,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      financial,
      as.vector(paletteer_d("MetBrewer::OKeeffe2"))
    )(financial$composite),
    group = "Financial_Resources",
    popup = label_generator(financial)
    ) %>%
  addPolygons(
    data = community_resources,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      community_resources,
      'YlGnBu'
      )(community_resources$composite),
    group = "Community_Resources",
    popup = label_generator(community_resources)
    ) %>%
  addPolygons(
    data = infrastructure,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      infrastructure,
      as.vector(paletteer_d("Redmonder::sPBIRdPu"))
      )(infrastructure$composite),
    group = "Infrastructure",
    popup = label_generator(infrastructure)
    ) %>%
  addPolygons(
    data = food_insecurity,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(food_insecurity)(food_insecurity$composite),
    group = "Food_Security",
    popup = label_generator(food_insecurity)
    ) %>%
  addPolygons(
    data = population,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      population,
      as.vector('YlOrBr')
      )(population$composite),
    group = "Population",
    popup = label_generator(population)
    ) %>%
  addPolygons(
    data = food_processors,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      food_processors,
      as.vector(paletteer_d("Redmonder::sPBIYlGn"))
      )(food_processors$composite),
    group = "Food_Processors",
    popup = label_generator(food_processors)
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      natural, 
      as.vector(paletteer_d("MetBrewer::Hokusai2"))),
    opacity = 1,
    values = natural$composite,
    title = HTML('Natural Resources<br>Index Score'),
    group = "Natural_Resources",
    className = "info legend Natural_Resources"
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      agriculture, 
      as.vector(paletteer_d("MetBrewer::VanGogh3"))),
    opacity = 1,
    values = agriculture$composite,
    title = HTML('Agricultural Resources<br>Index Score'),
    group = "Agricultural_Resources",
    className = 'info legend Agricultural_Resources') %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      financial,
      as.vector(paletteer_d("MetBrewer::OKeeffe2"))
      ),
    opacity = 1,
    values = financial$composite,
    title = HTML('Financial Resources<br>Index Score'),
    group = "Financial_Resources",
    className = "info legend Financial_Resources"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      community_resources,
      'YlGnBu'
      ),
    opacity = 1,
    values = community_resources$composite,
    title = HTML('Commnunity Resources<br>Index Score'),
    group = "Community_Resources",
    className = 'info legend Community_Resources') %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      food_processors,
      as.vector(paletteer_d("Redmonder::sPBIYlGn"))
      ),
    opacity = 1,
    values = food_processors$composite,
    title = HTML('Food Processors<br>Index Score'),
    group = "Food_Processors",
    className = "info legend Food_Processors") %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      infrastructure,
      as.vector(paletteer_d("Redmonder::sPBIRdPu"))
    ),
    opacity = 1,
    values = infrastructure$composite,
    title = HTML('Infrastructure<br>Index Score'),
    group = "Infrastructure",
    className = "info legend Infrastructure") %>%
  addLegend(
    "bottomright",
    pal = pal_generator(food_insecurity),
    opacity = 1,
    values = food_insecurity$composite,
    title = HTML('Food Security<br>Index Score'),
    group = "Food_Security",
    className = "info legend Food_Security") %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      population, "YlOrBr"
      ),
    opacity = 1,
    values = population$composite,
    title = HTML('Population<br>Index Score'),
    group = "Population",
    className = "info legend Population") %>%
  addLayersControl(
    baseGroups = c(
      "Agricultural_Resources",
      "Infrastructure",
      "Food_Security",
      "Population",
      "Food_Processors",
      "Community_Resources",
      "Financial_Resources",
      "Natural_Resources"
    ),
    options = layersControlOptions(collapsed = TRUE)
  ) %>%
    htmlwidgets::onRender(
      "
        function(el, x) {
           var updateLegend = function () {
              var selectedGroup = document.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);

              document.querySelectorAll('.legend').forEach(a => a.hidden=true);
              document.querySelectorAll('.legend').forEach(l => {
                 if (l.classList.contains(selectedGroup)) l.hidden=false;
              });
           };
           updateLegend();
           this.on('baselayerchange', el => updateLegend());
        }"
    ) %>%
  bslib::card(full_screen = TRUE)
```

#### Additional explanatory variables

##### Rural-Urban Continuum Classification

```{r ruc data grab}

## Urban-rural continuum
ruc_url <- 'https://www.ers.usda.gov/webdocs/DataFiles/53251/Ruralurbancontinuumcodes2023.xlsx?v=3167.7'

ruc <- read.xlsx(ruc_url) %>%
  select(FIPS, RUCC_2023, Description) %>%
  mutate(RUCC_2023 = as.factor(RUCC_2023)) %>%
  rename(fips = FIPS)

ruc_sf <- counties %>%
  merge(ruc, by = 'fips') %>%
  mutate(RUCC_2023 = as.factor(RUCC_2023)) %>%
  st_transform(4326)
```

```{r rural and underserved data grab}

## Rural and Underserved designation
rural_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_rural-list_2024.csv'
rural_data <- read.csv(rural_data_url)
rural_data$FIPS.Code <- sapply(rural_data$FIPS.Code, add_leading_zero)
underserved_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_underserved-list_2024.csv'
underserved_data <- read.csv(underserved_data_url)
underserved_data$FIPS.Code <- sapply(underserved_data$FIPS.Code, add_leading_zero)
underserved_sf <- counties %>%
  mutate(
    is_rural = as.factor(ifelse(fips %in% rural_data$FIPS.Code, 1, 0)),
    is_underserved = as.factor(ifelse(fips %in% underserved_data$FIPS.Code, 1, 0))
    ) %>%
  #select(-county_name) %>%
  st_transform(4326)

underserved <- underserved_sf %>%
  st_drop_geometry()
```

```{r poverty data grab}

## Poverty
pov_url <- 'https://www2.census.gov/programs-surveys/saipe/datasets/2022/2022-state-and-county/est22all.xls'
pov <- rio::import(file = pov_url)
pov <- tail(pov, -2) %>%
  row_to_names(row_number = 1)
pov$FIPS <- paste0(pov$`State FIPS Code`, pov$`County FIPS Code`)
pov <- data.frame(pov) %>%
  filter(County.FIPS.Code != '000') %>%
  mutate(poverty_rate = as.numeric(Poverty.Percent..All.Ages)) %>%
  select(FIPS, poverty_rate) %>%
  rename(fips = FIPS)

pov_sf <- counties %>%
  merge(pov, by = 'fips') %>%
  st_transform(4326)
```

```{r ag proportion data grab}

## Ag proportion
ag_acres <- getQuickstat(
  key = ag_census_api_key,
  program = "CENSUS",
  data_item = "AG LAND, CROPLAND - ACRES",
  geographic_level = "COUNTY",
  domain = "TOTAL",
  year = "2022",
  geometry = TRUE,
  lower48 = TRUE)

ag_acres <- ag_acres %>%
  mutate(area_meters = st_area(ag_acres),
         county_acres = area_meters * 0.000247105)

ag_acres$county_acres <- units::set_units(st_area(ag_acres), "acre")

ag_land <- ag_acres %>%
  select(GEOID, NAMELSAD, Value, county_acres) %>%
  drop_na() %>%
  rename(
    ag_acres = Value,
    county_name = NAMELSAD,
    fips = GEOID
    ) %>%
  mutate(ag_proportion = round(ag_acres / county_acres * 100), 1) %>%
  select(fips, ag_proportion) %>%
  drop_units() %>%
  st_drop_geometry() # geoms are wonky from the original soure
  
ag_land_sf <- counties %>%
  merge(ag_land, by = 'fips') %>%
  st_transform(4326)
```

##### Exploratory map of additional explanatory variables

```{r ruc and ag land map}

ruc_pal <- colorFactor(
  palette = as.vector(paletteer_d("trekcolors::tholian"))[1:9], 
  domain = ruc_sf$RUCC_2023)

underserved_pal <- colorFactor(
  palette= c('#F2EBBBFF', "#09283CFF"), 
  domain = underserved$is_underserved)

pov_pal <- colorNumeric(
  palette= as.vector(paletteer_d("MexBrewer::Revolucion")), 
  domain = pov_sf$poverty_rate,
  reverse = TRUE
  )

ag_pal <- colorNumeric(
  palette= as.vector(paletteer_d("Redmonder::sPBIYlGn")), 
  domain = ag_land_sf$ag_proportion
  )

# labels <- sprintf(
#   "<strong>%s</strong><br/>%s",
#   ruc_sf$county_name, ruc_sf$Description
# ) %>% lapply(htmltools::HTML)

my_map %>%
  addPolygons(
    data = ruc_sf,
    fillColor = ~ruc_pal(RUCC_2023),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'RUC',
    popup = glue(
      "<b>{ruc_sf$county_name}</b><br/>",
      "RUC class: {ruc_sf$Description}") %>%
      lapply(htmltools::HTML)
  ) %>%
  addPolygons(
    data = underserved_sf,
    fillColor = ~underserved_pal(is_underserved),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Underserved',
    popup = glue(
      "<b>{underserved_sf$county_name}</b><br/>",
      "Underserved: {underserved_sf$is_underserved}") %>%
      lapply(htmltools::HTML)
  ) %>%
  addPolygons(
    data = pov_sf,
    fillColor = ~pov_pal(poverty_rate),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Poverty',
    popup = glue(
      "<b>{pov_sf$county_name}</b><br/>",
      "Poverty Rate: {pov_sf$poverty_rate}&#37;") %>%
      lapply(htmltools::HTML)
  ) %>%
  addPolygons(
    data = ag_land_sf,
    fillColor = ~ag_pal(ag_proportion),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Ag_Proportion',
    popup = glue(
      "<b>{ag_land_sf$county_name}</b><br/>",
      "Ag Proportion: {ag_land_sf$ag_proportion}&#37;") %>%
      lapply(htmltools::HTML)
  ) %>%
  addLegend(
    "bottomright",
    #pal = ruc_pal,
    opacity = 1,
    values = ruc_sf$RUCC_2023,
    colors = as.vector(paletteer_d("trekcolors::tholian"))[1:9],
    labels = c('Most Urban',"","","","","","","","Most Rural"),
    title = HTML('Rural-Urban<br>Continuum Class'),
    group = "RUC",
    className = "info legend RUC"
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = ruc_sf$RUCC_2023,
    colors = c('#F2EBBBFF', "#09283CFF"),
    labels = c('Not Undereserved', "Underserved"),
    title = HTML('Classification'),
    group = "Underserved",
    className = "info legend Underserved"
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = pov_sf$poverty_rate,
    pal = pov_pal,
    #labels = c('Not Undereserved', "Underserved"),
    title = HTML('Poverty Rate'),
    group = "Poverty",
    className = "info legend Poverty"
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = ag_land_sf$ag_proportion,
    pal = ag_pal,
    #labels = c('Not Undereserved', "Underserved"),
    title = HTML('Land in Ag'),
    group = "Ag_Proportion",
    className = "info legend Ag_Proportion",
    labFormat = labelFormat(
      suffix = "%"
    )
    ) %>%
  addLayersControl(
    baseGroups = c(
      "Poverty",
      "RUC",
      "Underserved",
      "Ag_Proportion"
    ),
    options = layersControlOptions(collapsed = TRUE)
  ) %>%
  htmlwidgets::onRender(
      "
        function(el, x) {
           var updateLegend = function () {
              var selectedGroup = document.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);

              document.querySelectorAll('.legend').forEach(a => a.hidden=true);
              document.querySelectorAll('.legend').forEach(l => {
                 if (l.classList.contains(selectedGroup)) l.hidden=false;
              });
           };
           updateLegend();
           this.on('baselayerchange', el => updateLegend());
        }"
    ) %>%
  bslib::card(full_screen = TRUE)

```

```{r combine all data for PCA}

comm_wealth <- comm_wealth_all %>%
  select(fips, year, variable_name, value) %>%
  group_by(fips, variable_name) %>%
  summarise(value = mean(value, na.rm = TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = variable_name, values_from = value) %>%
  select(-broad_11)

d <- comm_wealth %>%
  merge(ruc, by = 'fips') %>%
  merge(underserved, by = 'fips') %>%
  merge(pov, by = 'fips') %>%
  merge(ag_land, by = 'fips')

rownames(d) <- d$fips

# remove non-numeric variables and add them back after PCA
d_factors <- d %>%
  select_if(is.factor)

d <- d %>% 
  select(-fips) %>% 
  select_if(is.numeric)

for(i in 1:ncol(d)){
  d[is.na(d[,i]), i] <- mean(d[,i], na.rm = TRUE)
}
```

### Community characteristics and LAMP funding

##### Plotting each variable against total LAMP award money received

```{r prepping wealth vs award data}

# join lamp_by_county and individual `overall` scores
lamp_by_county2 <- lamp_by_county %>%
  st_drop_geometry()

clean_up <- function(d) {
  return (d %>%
          st_drop_geometry() %>%
          select(fips, overall))
}

pop_url <- 'https://www.ers.usda.gov/webdocs/DataFiles/48747/PopulationEstimates.csv?v=8269.9'

pop <- read.csv(pop_url) %>%
  filter(Attribute == 'CENSUS_2020_POP',
         FIPStxt != 0) %>%
  select(FIPStxt, Value) %>%
  rename(
    population_2020 = Value,
    fips = FIPStxt
    )

pop$fips <- sapply(pop$fips, add_leading_zero)

# clean up lamp data and add total county grant $ column before joining
d2 <- d %>%
  merge(d_factors, by = 0) %>%
  rename(fips = Row.names) %>%
  merge(lamp_by_county2, by = 'fips') %>%
  merge(pop, by = 'fips') %>%
  mutate(award_per_capita = Award.Amount / population_2020) %>%
  select(-population_2020)
```

```{r wealth vs award scatter plots}
#| fig-height: 15
#| fig-width: 10
#| fig-align: center
#| out-width: 100%

old_vars <- c(
  "acre_FSA", 
  "assn",
  "broad_16",
  "conserve_acre",
  "create_indus",
  "create_jobs",
  "ed_attain",
  "deposits",
  "est_CBP",
  "food_secure",
  "foodbev_est_CBP",
  "health_factors",
  "pc1b_manufacturing",
  "pc1f",
  "pc1c_artsdiversity",
  "pc1h_healtheducation",
  "pc1s_nonprofitsocialindustries",
  "pc1n_naturalamenitiesconservation",
  "pc2b_infrastructure",
  "pc2n_farmland",
  "pc2s_publicvoiceparticipation",
  "pc2c_creativeindustries",
  "pc2h_medicalfoodsecurity",
  "health_outcomes",
  "highway_km",
  "insured",
  "localgovfin",
  "museums",
  "natamen_scale",
  "nccs",
  "owner_occupied",
  "primary_care",
  "prime_farmland",
  "pub_lib",
  "pvote",
  "racial_div",
  "respn",
  "poverty_rate",
  "ag_proportion",
  "is_rural",
  "is_underserved",
  "RUCC_2023",
  "Award.Amount",
  "Acre_NFS"
  )

new_vars <- c(
  "Acres in conservation", 
  "Social establishments",
  "Broadband access",
  "Acres under easement",
  "Creative industry",
  "Jobs in the arts",
  "Education levels",
  "Band deposits",
  "County business patterns",
  "Food security",
  "Food & bev businesses",
  "Health factors",
  "pc1b_manufacturing",
  "pc1f",
  "pc1c_artsdiversity",
  "pc1h_healtheducation",
  "pc1s_nonprofitsocialindustries",
  "pc1n_naturalamenitiesconservation",
  "pc2b_infrastructure",
  "pc2n_farmland",
  "pc2s_publicvoiceparticipation",
  "pc2c_creativeindustries",
  "pc2h_medicalfoodsecurity",
  "Health outcomes",
  "Highways",
  "Insured rate",
  "Local gov finances",
  "Museum access",
  "Natural amenities",
  "Non-profits",
  "Home ownership",
  "Health care access",
  "Prime farmland",
  "Public libraries",
  "Voting rate",
  "Racial diversity",
  "Census response rate",
  "Poverty rate",
  "Ag land proportion",
  "Rural status",
  "Underserved status",
  "Rural continuum",
  "Total LAMP funding",
  "National forests"
  )

var_map <- bind_cols(old_vars, new_vars)
names(var_map) <- c("old_vars", "new_vars")

d3 <- d2 %>%
  drop_na() %>%
  filter(!county_name %in% c('Menominee County', 'Kidder County'))

id_vars <- c('fips', 'county_name', 'lamp_funded', 'award_per_capita')
measure_vars <- colnames(d2)[!colnames(d2) %in% id_vars]

d3 <- reshape2::melt(
  d3, id.vars = id_vars,
  measure.vars = measure_vars)

d3 <- d3 %>%
  merge(var_map, by.x = 'variable', by.y = 'old_vars') %>%
  select(-variable) %>%
  rename(variable = new_vars)

d3 <- d3 %>% mutate(value = as.numeric(value))

# Create a scatter plot with facets
p <- ggplot(d3 %>% filter(variable != "Total LAMP funding") %>% ungroup(),
            aes(x = value,
                y = award_per_capita)) +
     geom_point(aes(color = variable#,
                #text = paste("County:", county_name)
                ),
                alpha = 0.7, size = 2) +
     geom_smooth(method = 'lm', se = FALSE, color = 'grey25', linewidth = .4) +
     scale_color_manual(values = ggsci::pal_igv("default")(length(unique(d3$variable))-1)) +
     facet_wrap(~ variable, ncol = 4, scales = 'free_x') +
     labs(title = 'Community Wealth Indices vs LAMP $ Per Capita, 2006-2022',
          x = 'Total Award $ Per Capita, 2006-2022',
          y = '',
          caption = "Note: two counties, Menominee County (Michigan) and Kidder County (North Dakota), were removed from the dataset used for this plot because they were identified as outliers.") +
     #ylim(0, 1) +
     theme_minimal() +
     theme(
       legend.position = "none",
       strip.background = element_rect(fill="#2F414BFF"),
       strip.text = element_text(color = 'grey76', face = 'bold')
     )

p

```

### Dimension reduction with PCA

Started with 44 variables, which were reduced to 10 using a principal components analysis.

```{r principal components analysis}
#| fig-align: center
#| fig-width: 10
#| fig-height: 15
#| out-width: 100%

## PCA v2
res.pca <- prcomp(d, scale = TRUE)
#summary(res.pca)
#fviz_eig(res.pca, col.var="blue", ncp = 25)

var <- get_pca_var(res.pca)
#corrplot(var$cos2, is.corr=FALSE)

eig_vals <- res.pca$sdev
k <- length(eig_vals[eig_vals >= 1])

#var <- get_pca_var(res.pca)
#corrplot(var$cos2[,1:k], is.corr=FALSE)

# fviz_pca_var(res.pca,
#              col.var = "cos2", # Color by the quality of representation
#              gradient.cols = c("darkorchid4", "gold", "darkorange"),
#              repel = TRUE
#              )

# Contributions of variables to PCs 1 to 10
p1 <- fviz_contrib(res.pca, choice = "var", axes = 1, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) +
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p2 <- fviz_contrib(res.pca, choice = "var", axes = 2, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p3 <- fviz_contrib(res.pca, choice = "var", axes = 3, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", stroke = 10,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p4 <- fviz_contrib(res.pca, choice = "var", axes = 4, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p5 <- fviz_contrib(res.pca, choice = "var", axes = 5, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p6 <- fviz_contrib(res.pca, choice = "var", axes = 6, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p7 <- fviz_contrib(res.pca, choice = "var", axes = 7, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p8 <- fviz_contrib(res.pca, choice = "var", axes = 8, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p9 <- fviz_contrib(res.pca, choice = "var", axes = 9, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p10 <- fviz_contrib(res.pca, choice = "var", axes = 10, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "#25282AFF", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, 
          ncol=2, nrow=5, heights = c(100, 100),
          #font.label = list(size = 6, color = "black", face = "bold", family = 'Roboto'),
          align = 'hv',
          label.x = '', label.y = ''
)

eigenvectors <- res.pca$rotation
eigenvectors_keep <- eigenvectors[,1:k]
rotated_data <- data.frame(res.pca$x[,1:k])

#corr_matrix <- cor(rotated_data)
#ggcorrplot(corr_matrix)

```

#### Principal components

```{r rename principal component variables}

oldnames = colnames(rotated_data)
newnames = c("pc1_education", "pc2_arts", "pc3_conservation1", "pc4_farmland1",
             "pc5_infrastructure", "pc6_farmland2", "pc7_manufacturing",
             "pc8_conservation2", "pc9_foodbev", "pc10_civics")

reduced_d <- rotated_data %>% rename_at(vars(all_of(oldnames)), ~ newnames)

```

#### Community characteristics

##### Infrastructure

-   part of this data comes from Schmitt et al - the PCs developed in that paper

-   the other variables come from ... somewhere else?

```{r infrastructure}
#| fig-align: center
#| fig-width: 10
#| fig-height: 3

# infrastructure <- subsetter("Infrastructure") %>%
#   select(-broad_11)
# infrastructure <- pca_prep(infrastructure)
# 
# correlation <- cor(infrastructure, use = "complete.obs")
# c <- ggcorrplot(correlation, hc.order = TRUE, outline.col = "white", 
#            type = 'lower', colors = c("#E46726",  "white", "#6D9EC1"),
#            #ggtheme = ggplot2::theme_gray, 
#            lab = TRUE,
#            lab_size = 2.5, tl.cex = 6, title = "Correlation matrix -\nInfrastructure variables",
#            show.legend = FALSE)
# 
# h <- infrastructure %>%
#   pivot_longer(everything(), names_to= "variable", values_to = "value") %>%
#   mutate(value = round(value, 2)) %>%
#   ggplot(aes(value)) + 
#   geom_histogram(
#     linewidth = 0.6,
#     boundary = 0.5,
#     bins = 8,
#     color = '#2F414BFF',
#     fill = '#CCD99CFF',
#     ) + 
#   facet_wrap(
#     ~variable, 
#     scales = 'free_x',
#     ncol = 5
#     ) +
#   theme_minimal() +
#   theme(
#     strip.background =element_rect(fill="#2F414BFF"),
#     strip.text = element_text(color = 'grey76', face = 'bold'),
#     axis.title.x = element_blank(),
#     axis.title.y = element_blank()
#     ) +
#   labs(
#     title = "Histograms - Infrastructure variables",
#     ylab = '',
#     xlab = ''
#   )
# 
# h
```

```         
```

### Urban-Rural continuum data

This information can be used to control for the location of each county in relation to rural (and potentially agricultural) land.

```{r ruc data}

  
```

### Underserved communities

From Consumer Financial Bureau data

```{r underserved communities data}

# rural_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_rural-list_2024.csv'
# rural_data <- read.csv(rural_data_url)
# rural_data$FIPS.Code <- sapply(rural_data$FIPS.Code, add_leading_zero)
# 
# underserved_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_underserved-list_2024.csv'
# underserved_data <- read.csv(underserved_data_url)
# underserved_data$FIPS.Code <- sapply(underserved_data$FIPS.Code, add_leading_zero)
# 
# underserved <- counties %>%
#   mutate(
#     is_rural = as.factor(ifelse(GEOID %in% rural_data$FIPS.Code, 1, 0)),
#     is_underserved = as.factor(ifelse(GEOID %in% underserved_data$FIPS.Code, 1, 0))
#     ) %>%
#   st_transform(4326)
# 
# bivar_pal <- function(n){
#   return(c('#d3d3d3', '#9e3547', '#4279b0', '#311e3b'))
# }
# 
# my_map %>%
# # leaflet() %>%
# #   addTiles() %>%
#   bivariatechoropleths::addBivariateChoropleth(
#      map_data = underserved,
#      var1_name = is_rural,
#      var2_name = is_underserved,
#      ntiles= 2,
#      var1_label = "Rural",
#      var2_label = "Underserved",
#      weight = 1,
#      fillOpacity = 1,
#      color = "grey",
#      paletteFunction = bivar_pal, #pals::stevens.pinkblue,
#      highlightOptions = leaflet::highlightOptions(color = "orange",
#                                                   weight = 2,
#                                                   opacity = 1))
```

### Poverty

```{r}

# pov_url <- 'https://www2.census.gov/programs-surveys/saipe/datasets/2022/2022-state-and-county/est22all.xls'
# 
# pov <- rio::import(file = pov_url)
# pov <- tail(pov, -2) %>%
#   row_to_names(row_number = 1)
# 
# pov$FIPS <- paste0(pov$`State FIPS Code`, pov$`County FIPS Code`)
# 
# pov <- data.frame(pov) %>%
#   filter(County.FIPS.Code != '000') %>%
#   mutate(poverty_rate = as.numeric(Poverty.Percent..All.Ages)) %>%
#   select(FIPS, poverty_rate)
# 
# pov_sf <- counties %>%
#   merge(pov, by.x = 'GEOID', by.y = 'FIPS') %>%
#   st_transform(4326)
# 
# pov_pal <- colorNumeric(palette = 'magma', domain = pov_sf$poverty_rate, reverse = TRUE)
# 
# labels <- sprintf(
#   "<strong>%s</strong><br/>poverty rate: %s percent",
#   pov_sf$NAMELSAD, pov_sf$poverty_rate
# ) %>% lapply(htmltools::HTML)
# 
# my_map %>%
# # leaflet(pov_sf) %>%
# #   addTiles() %>%
#   addPolygons(
#     data = pov_sf,
#     fillColor = ~pov_pal(poverty_rate),
#     color = 'white',
#     opacity = 1,
#     fillOpacity = 1,
#     weight = 0.2,
#     label = labels,
#     labelOptions = labelOptions(
#       style = list("font-weight" = "normal", padding = "3px 8px"),
#       textsize = "15px",
#       direction = "auto")
#   ) %>%
#   addLegend(
#     data = pov_sf,
#     "bottomright", pal = pov_pal, values = ~poverty_rate,
#     title = "Poverty Rate",
#     #labFormat = labelFormat(prefix = "$"),
#     opacity = 1
#   )
```

### Ag land

```{r get ag census farmland data}

# # run this to see all of your options for data_item argument
# #View(allDataItem)
# ag_acres <- getQuickstat(
#   key = ag_census_api_key,
#   program = "CENSUS",
#   data_item = "AG LAND, CROPLAND - ACRES",
#   geographic_level = "COUNTY",
#   domain = "TOTAL",
#   year = "2022",
#   state = NULL,
#   geometry = TRUE,
#   lower48 = TRUE)
#   
# ag_acres <- ag_acres %>%
#   mutate(area_meters = st_area(ag_acres),
#          county_acres = area_meters * 0.000247105)
# 
# ag_acres$county_acres <- units::set_units(st_area(ag_acres), "acre")
# 
# ag_land <- ag_acres %>%
#   select(GEOID, Value, county_acres) %>%
#   drop_na() %>%
#   rename(ag_acres = Value) %>%
#   mutate(ag_proportion = round(ag_acres / county_acres * 100), 0) %>%
#   select(GEOID, ag_proportion) %>%
#   drop_units() %>%
#   st_transform(4326)
# 
# ag_colors <- as.vector(paletteer_d("Redmonder::sPBIYlGn"))
# ag_pal <- colorBin(palette = ag_colors, 
#                    domain = ag_land$ag_proportion,
#                    bins = 9)
# 
# labels <- sprintf(
#   "<strong>%s</strong><br/>Percentage in ag: %s&#37",
#   ag_land$GEOID, ag_land$ag_proportion) %>% 
#   lapply(htmltools::HTML)
# 
# my_map %>%
# # leaflet(ag_proportion) %>%
# #   addTiles() %>%
#   addPolygons(
#     data = ag_land,
#     fillColor = ~ag_pal(ag_proportion),
#     color = 'white',
#     opacity = 1,
#     fillOpacity = 1,
#     weight = 0.2,
#     label = labels,
#     labelOptions = labelOptions(
#       style = list("font-weight" = "normal", padding = "3px 8px"),
#       textsize = "15px",
#       direction = "auto")
#   ) %>%
#   addLegend(
#     data = ag_land,
#     "bottomright", pal = ag_pal, values = ~ag_proportion,
#     title = "% of county in ag",
#     labFormat = labelFormat(suffix = "%"),
#     opacity = 1
#   )
```

## Combine data

```{r}

# start with full list of counties and build from there
# df <- counties %>%
#   select(-NAMELSAD) %>%
#   st_drop_geometry() %>%
#   merge(infrastructure, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(food_processors, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(community_resources, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(population, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(financial, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(food_insecurity, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(natural, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(agriculture, by = 'GEOID') %>%
#   select(-c(overall, County, geometry)) %>%
#   st_drop_geometry() %>%
#   merge(select(ruc, c(GEOID, RUCC_2023)), by = 'GEOID') %>%
#   select(-geometry) %>%
#   st_drop_geometry() %>%
#   merge(select(underserved, c(GEOID, is_rural, is_underserved)), by = 'GEOID') %>%
#   select(-geometry) %>%
#   st_drop_geometry() %>%
#   merge(pov, by.x = 'GEOID', by.y = 'FIPS') %>%
#   merge(ag_land, by = 'GEOID') %>%
#   select(-geometry) %>%
#   st_drop_geometry()
```

## Cluster analysis

```{r}

# df <- df %>% 
#   column_to_rownames(., var = "GEOID") %>%
#   drop_na()
# df <- sapply(df, as.numeric)
# 
# # normalize the data to range of [0, 1]
# df_norm <- apply(df, 2, normalize)
# df_norm <- as.data.frame(df_norm)
# 
# result <- NbClust(df_norm, diss = NULL, distance = "euclidean",
#                   min.nc = 3, max.nc = 30, method = "kmeans",
#                   index = "kl")
# 
# print(result$All.index)
# # result$Best.nc
# # result$Best.partition
# membership <- result$Best.partition
# 
# # add cluster membership vector to data set
# df <- data.frame(df)
# df$cluster <- membership
# 
# # add fips code back
# #soc_cap$fips <- fips
# 
# # soc_cap <- soc_cap %>%
# #   select(fips, everything())
```

## Cluster exploration

```{r}

# df2 <- reshape2::melt(
#   df, id.vars = c('cluster'))
# 
# grp1 <- colnames(df)[1:4]
# 
# tests <- df2 %>%
#   group_by(variable, cluster) %>%
#   summarize(mean = mean(value))
# 
# p <- ggplot(filter(df2, variable %in% grp1), aes(cluster, value), shape = 21) +
#   geom_jitter(
#     aes(color=factor(cluster)),
#     shape=21, size = 1, alpha = 0.5, fill = 'grey', stroke = 0.9) + 
#       # scale_colour_manual(
#       #   values=c("white", "darkgreen"), 
#       #   labels = c("Did not receive\nLAMP funding", "Received\nLAMP funding")) +
#   facet_wrap(~ variable, ncol = 2, scales = 'free_y') +
#   theme_minimal() #+
#   # labs(title="County-level Social Capital Index, by cluster",
#   #      x ="Social Capital Cluster", y = "Social Capital Index",
#   #      color = "") +
#   # theme(legend.position="top")
#   
# p
```

### Dimension reduction

Use principal component analysis (PCA) to reduce dimensionality of datasets and retain only most important information.

```{r pc eh}


# 
# # infrastructure
# infrastructure_pc <- pca_reduce(infrastructure)
# # infrastructure_correlation <- cor(pca_prep(infrastructure), use = "complete.obs")
# # corrplot(correlation, #method = 'square', 
# #             tl.cex = 0.8, 
# #          tl.col = 'black', tl.srt = 45,
# #          type = 'upper', order = "hclust")
# 
# food_processors_pc <- pca_reduce(food_processors)
# community_resources_pc <- pca_reduce(community_resources)
# population_pc <- pca_reduce(population)
# financial_pc <- pca_reduce(financial)
# food_insecurity_pc <- pca_reduce(food_insecurity)
# natural_pc <- pca_reduce(natural)
# agriculture_pc <- pca_reduce(agriculture)
# 
# all_pcs <- infrastructure_pc %>%
#   merge(food_processors_pc, by = 0) %>%
#   select(-Row.names) %>%
#   merge(community_resources_pc, by = 0) %>%
#   select(-Row.names) %>%
#   merge(population_pc, by = 0) %>%
#   select(-Row.names) %>%
#   merge(financial_pc, by = 0) %>%
#   select(-Row.names) %>%
#   merge(natural_pc, by = 0) %>%
#   select(-Row.names) %>%
#   merge(agriculture_pc, by = 0) %>%
#   select(-Row.names)

```

## Regression

```{r regression analysis}

# test <- df %>%
#   merge(select(lamp_by_county, c(GEOID, lamp_funded)), by = 'GEOID') %>%
#   st_drop_geometry() %>%
#   select(-geometry)
#   
# # start with just a few variables as predictors
# predictors <- names(test)[names(test) != 'lamp_funded']
# 
# # Prepare the model formula
# denyprobit <- glm(paste("lamp_funded ~", paste(predictors[1:5], collapse = " + ")),
#                   family = binomial(link = "probit"), 
#                   data = test)
# 
# coeftest(denyprobit, vcov. = vcovHC, type = "HC1")
# 
# denylogit <- glm(lamp_funded ~ soc_cap_index, # + soc_cap_cluster, # + RUCC_2023, 
#                  family = binomial(link = "logit"), 
#                  data = df)
# 
# coeftest(denylogit, vcov. = vcovHC, type = "HC1")
```
