---
title: "Analyzing the Role of Community and Individual Factors in LAMP Grant Funding: Identifying Diverse Barriers Across Clustered US Counties"
subtitle: "FAS Food Systems Impact Fellowship Capstone Project, 2024"
author: "Elliot Hohn\nSr. Agricultural Data Scientist Impact Fellow"
execute:
  echo: false
  warning: false
format:
  html:
    theme: simplex
    fontsize: 1.1em
    linestretch: 1.7
    mainfont: avenir
    max-width: 2400px
    margin-left: 0px
    margin-right: 0px
    toc: true
    toc-expand: 2
    #page-layout: full
    #page-layout: custom
fig-align: center
editor: visual
---

```{r environment setup}
#| include: false

library(tidyverse)
library(sf)
library(openxlsx)
library(corrplot)
library(NbClust)
library(broom)
library(caret)
library(tidycensus)
library(tidyUSDA)
library(FactoMineR)
library(factoextra)
library(leaflet)
library(units)
library(lmtest)
library(AER)
library(ggthemes)
library(shiny)
library(rmarkdown)
library(plotly)
library(reshape2)
library(bivariatechoropleths)
library(biscale)
library(rio)
library(janitor)
library(paletteer)
library(scales)
library(ggpubr)
library(ggcorrplot)
library(glue)
library(ggsci)
library(parameters)
library(rstatix)
library(DT)
library(extrafont)
library(ggdist)
library(lubridate)
library(gt)
library(gridExtra)
library(patchwork)


census_api_key(Sys.getenv("CENSUS_API_KEY"))
ag_census_api_key <- Sys.getenv("AG_CENSUS_API_KEY")

# reusable function for normalizing data
normalize <- function(x){
  round((x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)), 4)
}

options(
  scipen = 999,
  dplyr.summarise.inform=FALSE
  )

my_crs <- 5070

my_map <- leaflet(options = leafletOptions(minZoom = 3)) %>%
  #addTiles() %>%
  addProviderTiles(providers$CartoDB.Positron) %>%
  setMaxBounds(
    lng1 = -127.8,
    lat1 = 52.5,
    lng2 = -63.8,
    lat2 = 21.4)

subsetter <- function(topic) {
  d <- comm_wealth_all %>%
    filter(topic_area == topic) %>%
    select(fips, year, variable_name, value) %>%
    group_by(fips, variable_name) %>%
    summarise(value = mean(value, na.rm = TRUE)) %>%
    ungroup() %>%
    pivot_wider(names_from = variable_name, values_from = value)

  cols <- colnames(select_if(d, is.numeric))
  d <- d %>%
    mutate(
      across(all_of(cols), normalize))

  d$mean <- rowMeans(d[,cols], na.rm = TRUE)
  d$percentile <- ntile(d$mean, 100)
  
  d <- counties %>%
    merge(d, by = 'fips', all = TRUE) %>%
    st_transform(4326) %>%
    st_set_geometry('geometry') %>%
    select(-mean)

  return(d)
}

pca_prep <- function(d){
  rownames(d) <- d$GEOID
  d <- d %>%
    st_drop_geometry() %>%
    drop_na() %>%
    select(-c(GEOID, county_name, percentile))
  return(d)
}

# pca_reduce <- function(d){
#   pca_results <- PCA(pca_prep(d), graph = FALSE)
#   eig_keepers <- data.frame(pca_results$eig) %>%
#     filter(eigenvalue >= 1.0)
#   comps <- nrow(eig_keepers)
#   if (comps > 0) {
#     scores <- pca_results$var$coord %>% as_tibble()
#     df_reduced <- scores[,1:comps]
#     colnames(df_reduced) <- paste(deparse(substitute(d)), colnames(df_reduced), sep = "_")
#     return(data.frame(df_reduced))
#   } else {
#     return(NULL)
#   }
# }

# font_import()
# loadfonts(device = "all", quiet = TRUE)

theme_set(theme_void(base_family = "Roboto"))

theme_update(
  axis.text.x = element_text(color = "black", face = "bold", size = 14, 
                             margin = margin(t = 6)),
  axis.text.y = element_text(color = "black", size = 14, hjust = 1, 
                             margin = margin(r = 6), family = "Roboto Mono"),
  axis.line.x = element_line(color = "black", linewidth = 1),
  panel.grid.major.y = element_line(color = "grey90", size = .6),
  plot.background = element_rect(fill = "white", color = "white"),
  plot.margin = margin(rep(20, 4))
)


## theme for horizontal charts
theme_flip <-
  theme(
    axis.text.x = element_text(face = "plain", family = "Roboto Mono", size = 14),
    axis.text.y = element_text(face = "bold", family = "Roboto", size = 14),
    panel.grid.major.x = element_line(color = "grey90", linewidth = .6),
    panel.grid.major.y = element_blank(),
    legend.position = "top", 
    legend.text = element_text(family = "Roboto Mono", size = 18),
    legend.title = element_text(face = "bold", size = 18, margin = margin(b = 25))
  )
```

## Introduction

### Local Agriculture Market Program (LAMP)

The USDA's Agricultural Marketing Service (AMS) administers a variety of grant programs aimed at strengthening local and regional food systems. The Local Agriculture Market Program (LAMP) is one such program that supports direct producer-to-consumer marketing, food enterprises, and value-added agricultural products. Established under the 2018 Farm Bill, LAMP fosters community collaboration and public-private partnerships to improve regional food economies, aiding in the development of business strategies and infrastructure for local food systems. The Farm Bill provided LAMP \$50 million per year in mandatory funding and the programs received significant supplemental funding through the Consolidated Appropriations Act of 2021 and the American Rescue Plan of 2021.[^1] The major grant programs within LAMP include the [Local Food Promotion Program (LFPP)](https://www.ams.usda.gov/services/grants/lfpp), [Regional Food Systems Partnership (RFSP)](https://www.ams.usda.gov/services/grants/rfsp), and the [Farmers Market Promotion Program (FMPP)](https://www.ams.usda.gov/services/grants/fmpp).

[^1]: <https://www.ams.usda.gov/sites/default/files/media/LAMP_Report_to_Congress.pdf>

![Promotional materials for LAMP. Image: USDA-AMS, 2024](img/LAMP_Twitter.png){fig-align="center"}

### Building community capital through food systems investment

#### Allocating grant funding

The goals of the LAMP program include: (1) simplify the application processes and the reporting processes for the Program; (2) improve income and economic opportunities for producers and food businesses through job creation; and (3) strengthen capacity and regional food system development through community collaboration and expansion of mid-tier value chains.[^2]

[^2]: <https://www.ams.usda.gov/services/grants/lamp>. Accessed April 20, 2024

Each program within LAMP includes a set of constraints intended to improve the allocation of resources to specific program activity areas.

In 2021, AMS partnered with Florida A&M University and the University of Maryland Eastern Shore on a project focusing on the following goals[^3]:

[^3]: <https://www.ams.usda.gov/sites/default/files/media/MSDUSDAAMSGrantApplicantTASociallyDisadvantaged.pdf>

1.  Evaluate barriers to AMS grant opportunities for socially disadvantaged communities

2.  Invest in building trust and confidence between these communities and the USDA

3.  Take action to rectify inequalities in program access through targeted outreach, training, and technical assistance.

The results of this work are intended to be used to improve access and reduce barriers for all applicants, presumably part of the agency's renewed efforts to address USDA’s history of systemic discrimination.[^4]

[^4]: Kashyap, Pratyoosh, Becca B.R. Jablonski, and Allison Bauman. “Exploring the Relationships among Stocks of Community Wealth, State Farm to School Policies, and the Intensity of Farm to School Activities.” *Food Policy* 122 (January 2024): 102570. <https://doi.org/10.1016/j.foodpol.2023.102570>.

#### Community preparedness

Recent research suggests that the success of food system interventions, policies, and strategies for local economic development may hinge on the preexisting levels of community capital.[^5]

[^5]: Schmit, Todd M., Becca B.R. Jablonski, Alessandro Bonanno, and Thomas G. Johnson. “Measuring Stocks of Community Wealth and Their Association with Food Systems Efforts in Rural and Urban Places.” *Food Policy* 102 (July 2021): 102119. <https://doi.org/10.1016/j.foodpol.2021.102119>.

Additional research showed positive associations between cultural and social capital and farm to school activity.[^6]

[^6]: Kashyap, Pratyoosh, Becca B.R. Jablonski, and Allison Bauman. “Exploring the Relationships among Stocks of Community Wealth, State Farm to School Policies, and the Intensity of Farm to School Activities.” *Food Policy* 122 (January 2024): 102570. <https://doi.org/10.1016/j.foodpol.2023.102570>.

Much of this research highlights community assets that are often overlooked in community development work.[^7]

[^7]: Kashyap, Pratyoosh, Becca B.R. Jablonski, and Allison Bauman. “Exploring the Relationships among Stocks of Community Wealth, State Farm to School Policies, and the Intensity of Farm to School Activities.” *Food Policy* 122 (January 2024): 102570. <https://doi.org/10.1016/j.foodpol.2023.102570>.

## Objective

This report intends to lay the groundwork for an analytic approach that helps determine which community characteristics are associated with LAMP grant funding allocation. This could help determine if there is something akin to a "threshold of community preparedness" the unknowingly results in certain low-resource communities being excluded from LAMP programming. If so, the results of this research could provide insight into the particular characteristics associated with LAMP access, which could help agency staff to better allocate resources to ensure equitable access to grant funds.

## Methods

### Data access and aggregation

As a first step, a variety of data sets were obtained, cleaned, organized, and used for general data exploration. Information on specific datasets and sources can be found below. All work was done using the open source statistical software R version 4.4.0.[^8]

[^8]: <https://www.r-project.org/>

#### LAMP grant data

```{r load lamp and join data}
#| output: false

# Data downloaded directly from URL on the LAMP Navigator webpage
lamp_url <- 'https://www.ams.usda.gov/sites/default/files/media/LAMPDatasetandDataDictionary.xlsx'
lamp <- read.xlsx(lamp_url, sheet = 'LAMP Dataset 2006 to 2023') %>%
  rename(
    state = State,
    city = City.2
    ) %>%
  mutate(city = str_squish(str_trim(tolower(city)))) %>%
  filter(!state %in% c('HI', 'AK', 'PR'))

# Load US Cities dataset from github
url <- 'https://raw.githubusercontent.com/kelvins/US-Cities-Database/main/csv/us_cities.csv'
city_loc <- read.csv(url) %>%
  select(-c(ID, COUNTY)) %>%
  rename(
    city = CITY,
    state = STATE_CODE
  ) %>%
  mutate(city = str_squish(str_trim(tolower(city)))) %>%
  group_by(city, state) %>%
  filter(row_number()==1) %>% 
  ungroup()

# do the join
lamp <- merge(lamp, city_loc, by = c('city', 'state'), all.x = TRUE)

# convert to sf object
lamp_sf <- lamp %>% 
  drop_na(LATITUDE, LONGITUDE) %>%
  st_as_sf(coords = c("LONGITUDE", "LATITUDE")) %>%
  st_set_crs(4326) %>%
  st_transform(4326)

# Load counties data (downloaded somewhere on the interwebs...)
counties <- st_read('data/cb_2021_us_county_20m/cb_2021_us_county_20m.shp') %>%
  filter(!STATE_NAME %in% c('Alaska', 'Hawaii', 'Puerto Rico')) %>%
  rename(
    county_name = NAMELSAD,
    fips = GEOID
    ) %>%
  select(fips, county_name, geometry) %>%
  #st_set_crs(4326) %>%
  st_transform(4326)

# spatial join points within counties
lamp_by_county <- counties %>%
  st_join(lamp_sf, join = st_contains, left = TRUE) %>%
  group_by(fips) %>%
  mutate(total_grant = sum(Award.Amount)) %>%
  mutate(lamp_funded = as.factor(ifelse(is.na(Award.Amount) | Award.Amount == 0, 0, 1))) %>%
  #rename(County = NAMELSAD) %>%
  select(fips, county_name, lamp_funded, Award.Amount)
```

Information on LAMP awards came from the LAMP Navigator website, where AMS has made this information publicly available, along with a dashboard for sorting, filtering, and visualizing the grant information.[^9] Along with information about the organizations receiving the grant, the dataset includes information on the purpose of the grant (e.g., technical assistance, infrastructure, processing), the match amount, and the total project cost.

[^9]: <https://www.ams.usda.gov/data/lamp-navigator>

##### LAMP grant award amounts, 2006 - 2023

###### Each green dash represents a single grant award

```{r lamp grant distribution}
#| fig-height: 6
#| fig-width: 12
#| fig-align: center
#| out-width: 100%

l <- lamp %>%
  mutate(
    Year = ymd(Year, truncated = 2L)
  )

g <- ggplot(l, aes(x = Year, y = Award.Amount)) +
  geom_point(shape = 95, size = 10, alpha = .4, color = '#005440') +
  theme(legend.position="none") +
  scale_x_date(date_breaks = '1 year', date_labels = "'%y") + 
  scale_y_continuous(labels = dollar) +
  annotate(
    geom = 'text',
    x = as.Date('2011-01-01'),
    y = 400000,
    label = 'No 2013 awards\ndue to lapse\nof funding',
    size = 4,
    color = 'grey35'
  ) +
  annotate(
    geom = "curve",
    x = as.Date('2011-10-01'),
    xend = as.Date('2013-01-01'),
    y = 350000, yend = 20000,
    curvature = -0.3,
    arrow = arrow(),
    color = 'grey35'
  )

g
```

##### Geographic distribution of LAMP Grants, 2006-2023

```{r lamp funded leaflet map}

d_map_lamp <- lamp_sf
d_map_lamp$point_size <- scales::rescale(d_map_lamp$Award.Amount, c(1, 15))

grant_colors <- as.vector(paletteer_d("nbapalettes::thunder")[1:3])
pal <- colorFactor(
  palette = grant_colors, domain = d_map_lamp$Grant.Type)

county_pal <- colorBin(
      palette = as.vector(paletteer_d("PrettyCols::Teals"))[1:6],
      bins = 6,
      reverse = TRUE,
      domain = c(
        min(lamp_by_county$Award.Amount, na.rm = TRUE),
        max(lamp_by_county$Award.Amount, na.rm=TRUE)
      ),
      na.color = '#F0EBE9'
      )

labels <- sprintf(
  "<strong>%s</strong><br/>Year: %g<br/>Award amount: %s<br/>Grant type: %s<br/>Project type: %s",
  d_map_lamp$Organization, d_map_lamp$Year, scales::dollar(d_map_lamp$Award.Amount),
  d_map_lamp$Grant.Type, d_map_lamp$Project.Type
) %>% lapply(htmltools::HTML)

my_map %>%
  addCircleMarkers(
    data = d_map_lamp,
    radius = ~ point_size,
    color = ~pal(Grant.Type),
    stroke = FALSE,
    fillOpacity = 0.5,
    label = labels,
    group = 'City/Town',
    labelOptions = labelOptions(
      style = list("font-weight" = "normal", padding = "3px 8px"),
      textsize = "15px",
      direction = "auto")
 ) %>%
  addPolygons(
    data = lamp_by_county,
    weight = 0.5,
    color = 'white',
    fillColor = ~county_pal(Award.Amount),
    fillOpacity = 1,
    group = "County",
    popup = glue(
      "<b>{lamp_by_county$county_name}</b><br/>",
      "Total Awards: {scales::dollar(lamp_by_county$Award.Amount)}") %>%
      lapply(htmltools::HTML)
  ) %>%
  addLegend(
    "bottomright",
    pal = county_pal,
    na.label = "No grants",
    opacity = 1,
    values = lamp_by_county$Award.Amount,
    title = HTML('Total LAMP Awards<br>Received, 2006-2023'),
    group = "County",
    labFormat = labelFormat(
      big.mark = ",",
      prefix = "$"
    ),
    className = "info legend County"
  ) %>%
  addLegend(
    data = d_map_lamp, "bottomright", pal = pal, 
    values = ~Grant.Type,
    title = "Grant Type",
    opacity = 1,
    className = "info legend City/Town"
  ) %>% addLayersControl(
    baseGroups = c(
      "City/Town",
      "County"
    ),
    options = layersControlOptions(collapsed = FALSE)
  ) %>%
    htmlwidgets::onRender(
      "
        function(el, x) {
           var updateLegend = function () {
              var mapContainer = el.closest('.leaflet-container');
              var selectedGroup = mapContainer.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);

              mapContainer.querySelectorAll('.legend').forEach(a => a.hidden=true);
              mapContainer.querySelectorAll('.legend').forEach(l => {
                 if (l.classList.contains(selectedGroup)) l.hidden=false;
              });
           };
           updateLegend();
           this.on('baselayerchange', el => updateLegend());
        }"
    ) %>%
  bslib::card(full_screen = TRUE)
```

#### Community characteristics

A variety of socioeconomic and environmental factors were investigated to assess how they may influence the likelihood of receiving a LAMP grant. These factors include indicators of community wealth, which encompasses social capital, natural capital, financial capital, and a variety of other forms of wealth, which have been shown impacts the ability to engage and participate in such programs.[^10] Additionally, it includes factors related to poverty and food security, which have been shown to exacerbate vulnerabilities and influence accessibility and participation in programs.[^11] Finally, considering the food systems-focus of LAMP, factors related to urbanization and proximity to agricultural land were included because they can influence market dynamics and food system connectivity.[^12]

[^10]: Flora, Cornelia Butler, Jan L. Flora, and Stephen P. Gasteyer. *Rural Communities: Legacy and Change*. 4th ed. Routledge, 2018. <https://doi.org/10.4324/9780429494697>.

[^11]: Alisha Coleman-Jensen, Matthew P. Rabbitt, Christian A. Gregory, and Anita Singh. 2021. Household Food Security in the United States in 2020, ERR-298, U.S. Department of Agriculture, Economic Research Service.

[^12]: Pothukuchi, Kameshwari, and Jerome L. Kaufman. “The Food System: A Stranger to the Planning Field.” *Journal of the American Planning Association* 66, no. 2 (June 30, 2000): 113–24. <https://doi.org/10.1080/01944360008976093>.

##### Indicators of community wealth

```{r prep comm wealth data}

## Community Wealth
comm_wealth_url <- 'https://raw.githubusercontent.com/CSU-Local-and-Regional-Food-Systems/USDA-AMS-Data-and-Metrics/main/Indicators%20of%20Community%20Wealth/community_wealth.csv'
comm_wealth_all <- read.csv(comm_wealth_url) %>%
  filter(fips > 100) %>%
  filter(!county_name %in% c('Menominee County', 'Kidder County'))# remove national level rows 

# Function to add leading 0 to 4-digit fips values in comm_wealth to facilitate later joins
add_leading_zero <- function(x) {
  # Check if the number has 4 digits
  ifelse(nchar(x) == 4, paste0("0", x), x)
}

# apply funcion to fips column
comm_wealth_all$fips <- sapply(comm_wealth_all$fips, add_leading_zero)

comm_wealth_all <- comm_wealth_all %>%
  filter(variable_name != 'broad_11')
```

Community wealth data were accessed via the USDA AMS Data and Metrics GitHub repository.[^13] The main source of data was the "Indicators of Community Wealth" dataset within this repository, which was the result of various pre-processing steps that are outlined within the Rmarkdown file included in the repo.

[^13]: <https://github.com/CSU-Local-and-Regional-Food-Systems/USDA-AMS-Data-and-Metrics/tree/main>

```{r community wealth variables table}

vars <- unique(comm_wealth_all$variable_name)

# cats <- list()
# for (var in vars) {
#   my_cat <- comm_wealth_all$category[match(var, comm_wealth_all$variable_name)]
#   cats <- append(cats, my_cat)
# }
# cats <- unlist(cats)

descriptions_csv <- read.csv('data/metadata_all_files.csv')

descriptions <- list()
for (var in vars) {
  my_desc <- descriptions_csv$variable_definition[match(var, descriptions_csv$variable_name)]
  descriptions <- append(descriptions, my_desc)
}
descriptions <- unlist(descriptions)

cats <- list()
for (var in vars) {
  my_cat <- descriptions_csv$category[match(var, descriptions_csv$variable_name)]
  cats <- append(cats, my_cat)
}
cats <- unlist(cats)

sources <- list()
for (var in vars) {
  my_source <- descriptions_csv$source[match(var, descriptions_csv$variable_name)]
  sources <- append(sources, my_source)
}
sources <- unlist(sources)

d <- data.frame(
  list(
    'variable' = vars,
    'category' = cats,
    'description' = descriptions,
    'source' = sources
  )
)

gt_tbl <- d |>
  mutate(category = replace_na(category, "Uncategorized")) |>
  group_by(category) |>
  gt(rowname_col = "variable") %>%
  cols_hide('category') %>%
  tab_header(
    title = "Indicators of community wealth variables",
    subtitle = "Descriptions and sources of data used in analysis"
  ) |>
  # tab_source_note(
  #   source_note = "Source: The World Almanac and Book of Facts, 1975, page 406."
  # ) |>
  # tab_source_note(
  #   source_note = md("Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.")
  # ) |>
  # tab_footnote(
  #   footnote = md("The **largest** by area."),
  #   locations = cells_body(
  #     columns = size, rows = largest
  #   )
  # ) |>
  # tab_footnote(
  #   footnote = "The lowest by population.",
  #   locations = cells_body(
  #     columns = size, rows = contains("arc")
  #   )
  # ) |> 
  tab_row_group(
    label = html("<strong>Community Characteristics</strong>"),
    rows = category == 'Community Characteristics'
  ) |>
  tab_row_group(
    label = html("<strong>Processing & Distribution</strong>"),
    rows = category == 'Processing & Distribution'
  ) |>
  tab_row_group(
    label = html("<strong>Food Access</strong>"),
    rows = category == 'Food Access'
  ) |>
  tab_row_group(
    label = html("<strong>Institutions</strong>"),
    rows = category == 'Institutions'
  ) |>
  tab_row_group(
    label = html("<strong>Labor</strong>"),
    rows = category == 'Labor'
  ) |>
  tab_row_group(
    label = html("<strong>Demographics</strong>"),
    rows = category == 'Demographics'
  ) |>
  cols_label(
    description = "Description",
    source = "Data Source"
  ) |>
  tab_style(
    style = list(
      cell_fill("grey90"),
      cell_text(color = "black", weight = "bold")
      ),
    locations = cells_row_groups()
  ) |>
  tab_options(row.striping.include_table_body = FALSE) |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(
    font = google_font("Roboto")) |>
  tab_options(
    table.font.size = 11
  ) |>
  tab_options(quarto.disable_processing = TRUE)


# Show the gt table
gt_tbl

```

```{r wealth data subset}
#| warnings: false

# for map-making in next step
infrastructure <- subsetter("Infrastructure")
food_processors <- subsetter("Food Processors")
community_resources <- subsetter("Community Resources")
population <- subsetter("Population")
financial <- subsetter("Financial")
food_insecurity <- subsetter("Food Insecurity")
natural <- subsetter("Natural")
agriculture <- subsetter("Agriculture")
```

#### Distribution of community wealth metrics

For each category listed in the table above, all metrics within that category were normalized then averaged in order to create an overall category percentile score. The colors in each category map layer below correspond to this percentile score.

```{r wealth map}
#| warnings: false

bins <- seq(from = 0, to = 100, by = 20)
pal <- colorBin("YlOrRd", domain = 0:100, bins = bins)

pal_generator <- function(d, pal = 'RdPu') {
  return(colorQuantile(palette = pal, domain = d$percentile, n = 5, na.color = 'grey'))
}

# test_pal <- colorQuantile(
#   pal = 'RdPu',
#   domain = agriculture$
# )

label_generator <- function(d) {
  d_name <- deparse(substitute(d))
  label <- paste0("<strong>{", d_name, "$county_name}</strong>")
  for (i in 4:ncol(d)-1) {
    label <- paste0(label,'<br/>', colnames(d)[i], ': {', d_name, '$', colnames(d)[i], "}")
  }
  return(
    glue(label) %>% lapply(htmltools::HTML)
  )
}

my_map %>%
  addPolygons(
    data = natural,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      natural,
      as.vector(paletteer_d("MetBrewer::Hokusai2")))(natural$percentile),
    group = "Natural_Resources",
    popup = label_generator(natural),
    popupOptions = popupOptions(
      #keepInView = TRUE,
      closeOnClick = TRUE
    )
  ) %>%
  addPolygons(
    data = agriculture,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      agriculture,
      as.vector(paletteer_d("MetBrewer::VanGogh3"))
      )(agriculture$percentile),
    group = "Agricultural_Resources",
    popup = label_generator(agriculture)
    ) %>%
  addPolygons(
    data = financial,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      financial,
      as.vector(paletteer_d("MetBrewer::OKeeffe2"))
    )(financial$percentile),
    group = "Financial_Resources",
    popup = label_generator(financial)
    ) %>%
  addPolygons(
    data = community_resources,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      community_resources,
      'YlGnBu'
      )(community_resources$percentile),
    group = "Community_Resources",
    popup = label_generator(community_resources)
    ) %>%
  addPolygons(
    data = infrastructure,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      infrastructure,
      as.vector(paletteer_d("Redmonder::sPBIRdPu"))
      )(infrastructure$percentile),
    group = "Infrastructure",
    popup = label_generator(infrastructure)
    ) %>%
  addPolygons(
    data = food_insecurity,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(food_insecurity)(food_insecurity$percentile),
    group = "Food_Security",
    popup = label_generator(food_insecurity)
    ) %>%
  addPolygons(
    data = population,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      population,
      as.vector('YlOrBr')
      )(population$percentile),
    group = "Population",
    popup = label_generator(population)
    ) %>%
  addPolygons(
    data = food_processors,
    weight = 0.5,
    color = 'white',
    fillOpacity = 1,
    fillColor = pal_generator(
      food_processors,
      as.vector(paletteer_d("Redmonder::sPBIYlGn"))
      )(food_processors$percentile),
    group = "Food_Processors",
    popup = label_generator(food_processors)
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      natural, 
      as.vector(paletteer_d("MetBrewer::Hokusai2"))),
    opacity = 1,
    values = natural$percentile,
    #title = HTML('Natural Resources<br>Index Score'),
    group = "Natural_Resources",
    className = "info legend Natural_Resources",
    na.label = "No data"
  ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      agriculture, 
      as.vector(paletteer_d("MetBrewer::VanGogh3"))),
    opacity = 1,
    values = agriculture$percentile,
    #title = HTML('Agricultural Resources<br>Index Score'),
    group = "Agricultural_Resources",
    className = 'info legend Agricultural_Resources',
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      financial,
      as.vector(paletteer_d("MetBrewer::OKeeffe2"))
      ),
    opacity = 1,
    values = financial$percentile,
    #title = HTML('Financial Resources<br>Index Score'),
    group = "Financial_Resources",
    className = "info legend Financial_Resources",
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      community_resources,
      'YlGnBu'
      ),
    opacity = 1,
    values = community_resources$percentile,
    #title = HTML('Commnunity Resources<br>Index Score'),
    group = "Community_Resources",
    className = 'info legend Community_Resources',
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      food_processors,
      as.vector(paletteer_d("Redmonder::sPBIYlGn"))
      ),
    opacity = 1,
    values = food_processors$percentile,
    #title = HTML('Food Processors<br>Index Score'),
    group = "Food_Processors",
    className = "info legend Food_Processors",
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      infrastructure,
      as.vector(paletteer_d("Redmonder::sPBIRdPu"))
    ),
    opacity = 1,
    values = infrastructure$percentile,
    #title = HTML('Infrastructure<br>Index Score'),
    group = "Infrastructure",
    className = "info legend Infrastructure",
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(food_insecurity),
    opacity = 1,
    values = food_insecurity$percentile,
    #title = HTML('Food Security<br>Index Score'),
    group = "Food_Security",
    className = "info legend Food_Security",
    na.label = "No data"
    ) %>%
  addLegend(
    "bottomright",
    pal = pal_generator(
      population, "YlOrBr"
      ),
    opacity = 1,
    values = population$percentile,
    #title = HTML('Population<br>Index Score'),
    group = "Population",
    className = "info legend Population",
    na.label = "No data"
    ) %>%
  addLayersControl(
    baseGroups = c(
      "Agricultural_Resources",
      "Infrastructure",
      "Food_Security",
      "Population",
      "Food_Processors",
      "Community_Resources",
      "Financial_Resources",
      "Natural_Resources"
    ),
    options = layersControlOptions(collapsed = TRUE)
  ) %>%
  # htmlwidgets::onRender(
  #   "
  #       function(el, x) {
  #          var updateLegend = function () {
  #             var selectedGroup = document.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);
  # 
  #             document.querySelectorAll('.legend').forEach(a => a.hidden=true);
  #             document.querySelectorAll('.legend').forEach(l => {
  #                if (l.classList.contains(selectedGroup)) l.hidden=false;
  #             });
  #          };
  #          updateLegend();
  #          this.on('baselayerchange', el => updateLegend());
  #       }"
  # )
  
  
  
  htmlwidgets::onRender(
      "
        function(el, x) {
           var updateLegend = function () {
              var mapContainer = el.closest('.leaflet-container');
              var selectedGroup = mapContainer.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);

              mapContainer.querySelectorAll('.legend').forEach(a => a.hidden=true);
              mapContainer.querySelectorAll('.legend').forEach(l => {
                 if (l.classList.contains(selectedGroup)) l.hidden=false;
              });
           };
           updateLegend();
           this.on('baselayerchange', el => updateLegend());
        }"
    ) %>%
  bslib::card(full_screen = TRUE)
```

#### Additional community characteristics

##### Poverty rate

Count-level poverty rates were sourced from the 2022 US Census.[^14]

[^14]: U.S. Census Bureau. (n.d.). *SAIPE State and County Estimates for 2022*. Retrieved March 27, 2024, from <https://data.census.gov/>

```{r poverty data grab}

## Poverty
pov_url <- 'https://www2.census.gov/programs-surveys/saipe/datasets/2022/2022-state-and-county/est22all.xls'
pov <- rio::import(file = pov_url)
pov <- tail(pov, -2) %>%
  row_to_names(row_number = 1)
pov$FIPS <- paste0(pov$`State FIPS Code`, pov$`County FIPS Code`)
pov <- data.frame(pov) %>%
  filter(County.FIPS.Code != '000') %>%
  mutate(poverty_rate = as.numeric(Poverty.Percent..All.Ages)) %>%
  select(FIPS, poverty_rate) %>%
  rename(fips = FIPS)

pov_sf <- counties %>%
  merge(pov, by = 'fips') %>%
  st_transform(4326)
```

##### Farmland proportion

```{r ag proportion data grab}

#View(tidyUSDA::allDataItem)

## Ag proportion
cropland_acres_df <- getQuickstat(
  key = ag_census_api_key,
  program = "CENSUS",
  data_item = "AG LAND, CROPLAND - ACRES",
  geographic_level = "COUNTY",
  domain = "TOTAL",
  year = "2022",
  geometry = TRUE,
  lower48 = TRUE) %>%
  select(GEOID, NAMELSAD, Value) %>%
  rename(cropland_acres = Value)

pasture_acres_df <- getQuickstat(
  key = ag_census_api_key,
  program = "CENSUS",
  data_item = "AG LAND, PASTURELAND - ACRES",
  geographic_level = "COUNTY",
  domain = "TOTAL",
  year = "2022",
  geometry = TRUE,
  lower48 = TRUE) %>%
  st_drop_geometry() %>%
  select(GEOID, Value) %>%
  rename(pasture_acres = Value)

ag_acres_df <- cropland_acres_df %>%
  mutate(area_meters = st_area(cropland_acres_df),
         county_acres = area_meters * 0.000247105) %>%
  merge(pasture_acres_df, by = 'GEOID') %>%
  mutate(
    ag_acres = cropland_acres + pasture_acres) %>%
  select(GEOID, NAMELSAD, county_acres, ag_acres)

ag_acres_df$county_acres <- units::set_units(st_area(ag_acres_df), "acre")

ag_land <- ag_acres_df %>%
  select(GEOID, NAMELSAD, ag_acres, county_acres) %>%
  drop_na() %>%
  rename(fips = GEOID) %>%
  mutate(ag_proportion = round(ag_acres / county_acres * 100), 1) %>%
  select(fips, ag_proportion) %>%
  drop_units() %>%
  st_drop_geometry() # geoms are wonky from the original soure
  
ag_land_sf <- counties %>%
  merge(ag_land, by = 'fips') %>%
  st_transform(4326)
```

Data on total agricultural land were obtained from the 2022 Census of Agriculture.[^15]

[^15]: 2022 Census of Agriculture. QuickStats, State and County Data. \[Washington, D.C.\] :United States Department of Agriculture, National Agricultural Statistics Service, 2014.

##### "Rural" and "underserved" classification

```{r rural and underserved data grab}

## Rural and Underserved designation
rural_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_rural-list_2024.csv'
rural_data <- read.csv(rural_data_url)
rural_data$FIPS.Code <- sapply(rural_data$FIPS.Code, add_leading_zero)
underserved_data_url <- 'https://files.consumerfinance.gov/f/documents/cfpb_underserved-list_2024.csv'
underserved_data <- read.csv(underserved_data_url)
underserved_data$FIPS.Code <- sapply(underserved_data$FIPS.Code, add_leading_zero)
underserved_sf <- counties %>%
  mutate(
    is_rural = as.factor(ifelse(fips %in% rural_data$FIPS.Code, 1, 0)),
    is_underserved = as.factor(ifelse(fips %in% underserved_data$FIPS.Code, 1, 0)),
    classification = ifelse(
      is_rural == 1 & is_underserved == 1, 
      "Rural and Underserved",
      ifelse(
        is_rural == 1 & is_underserved == 0, 
        "Rural",
        ifelse(
          is_rural == 0 & is_underserved == 1, 
          "Underserved", 
          "Not rural or underserved"
        )
      )
    )) %>%
  #select(-county_name) %>%
  st_transform(4326)

underserved <- underserved_sf %>%
  st_drop_geometry()
```

Data on county-level classification as "rural" and/or "underserved" were obtained from the Consumer Financial Protection Bureau.[^16]

[^16]: <https://www.consumerfinance.gov/rural-or-underserved-tool/>

##### Rural-Urban Continuum Classification

```{r ruc data grab}

## Urban-rural continuum
ruc_url <- 'https://www.ers.usda.gov/webdocs/DataFiles/53251/Ruralurbancontinuumcodes2023.xlsx?v=3167.7'

ruc <- read.xlsx(ruc_url) %>%
  select(FIPS, RUCC_2023, Description) %>%
  mutate(RUCC_2023 = as.factor(RUCC_2023)) %>%
  rename(fips = FIPS)

ruc_sf <- counties %>%
  merge(ruc, by = 'fips') %>%
  mutate(RUCC_2023 = as.factor(RUCC_2023)) %>%
  st_transform(4326)
```

The categorization of each county on the rural-urban continuum came from the USDA-ERS.[^17]

[^17]: <https://www.ers.usda.gov/data-products/rural-urban-continuum-codes/>

##### Exploratory map of additional explanatory variables

```{r ruc and ag land map}

ruc_pal <- colorFactor(
  palette = as.vector(paletteer_d("trekcolors::tholian"))[1:9], 
  domain = ruc_sf$RUCC_2023,
  na.color = 'grey'
  )

underserved_pal <- colorFactor(
  palette= c('#d3d3d3', '#9e3547', '#311e3b', '#4279b0'), 
  domain = underserved_sf$classification)

pov_pal <- colorNumeric(
  palette= as.vector(paletteer_d("MexBrewer::Revolucion")), 
  domain = pov_sf$poverty_rate,
  reverse = TRUE
  )

ag_pal <- colorNumeric(
  palette= as.vector(paletteer_d("Redmonder::sPBIYlGn")), 
  domain = ag_land_sf$ag_proportion
  )

bivar_pal <- function(n){
  return(c('#d3d3d3', '#9e3547', '#4279b0', '#311e3b'))
}

# labels <- sprintf(
#   "<strong>%s</strong><br/>%s",
#   ruc_sf$county_name, ruc_sf$Description
# ) %>% lapply(htmltools::HTML)

m <- my_map %>%
  addPolygons(
    data = ruc_sf,
    fillColor = ~ruc_pal(RUCC_2023),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'RUC',
    popup = glue(
      "<b>{ruc_sf$county_name}</b><br/>",
      "RUC class: {ruc_sf$Description}") %>%
      lapply(htmltools::HTML)
  ) %>%
  addPolygons(
    data = underserved_sf,
    fillColor = ~underserved_pal(classification),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Rural_Underserved',
    popup = glue(
      "<b>{underserved_sf$county_name}</b><br/>",
      "Status: {underserved_sf$classification}") %>%
      lapply(htmltools::HTML)
  ) %>%
  # addBivariateChoropleth(
  #    map_data = underserved_sf,
  #    var1_name = 'is_rural',
  #    var2_name = 'is_underserved',
  #    ntiles = 2,
  #    var1_label = "Rural",
  #    var2_label = "Underserved",
  #    weight = 1,
  #    fillOpacity = 0.7,
  #    color = "grey",
  #    group = "test",
  #    paletteFunction = bivar_pal, #pals::stevens.pinkblue,
  #    highlightOptions = leaflet::highlightOptions(color = "orange",
  #                                                 weight = 2,
  #                                                 opacity = 1)
  #    ) %>%
  addPolygons(
    data = pov_sf,
    fillColor = ~pov_pal(poverty_rate),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Poverty',
    popup = glue(
      "<b>{pov_sf$county_name}</b><br/>",
      "Poverty Rate: {pov_sf$poverty_rate}&#37;") %>%
      lapply(htmltools::HTML)
  ) %>%
  addPolygons(
    data = ag_land_sf,
    fillColor = ~ag_pal(ag_proportion),
    color = 'white',
    opacity = 1,
    fillOpacity = 1,
    weight = 0.2,
    group = 'Ag_Proportion',
    popup = glue(
      "<b>{ag_land_sf$county_name}</b><br/>",
      "Ag Proportion: {ag_land_sf$ag_proportion}&#37;") %>%
      lapply(htmltools::HTML)
  ) %>%
  addLegend(
    "bottomright",
    #pal = ruc_pal,
    opacity = 1,
    values = ruc_sf$RUCC_2023,
    colors = as.vector(paletteer_d("trekcolors::tholian"))[1:9],
    labels = c('Most Urban',"","","","","","","","Most Rural"),
    title = HTML('Rural-Urban<br>Continuum Class'),
    group = "RUC",
    className = "info legend RUC",
    na.label = 'No data'
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = underserved_sf$classification,
    #colors = c('#F2EBBBFF', "#09283CFF"),
    pal = underserved_pal,
    #labels = c('Not Undereserved', "Underserved"),
    title = "", #HTML('Classification'),
    group = "Rural_Underserved",
    className = "info legend Rural_Underserved",
    na.label = 'No data'
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = pov_sf$poverty_rate,
    pal = pov_pal,
    #labels = c('Not Undereserved', "Underserved"),
    title = HTML('Poverty Rate'),
    group = "Poverty",
    className = "info legend Poverty",
    na.label = 'No data'
    ) %>%
  addLegend(
    "bottomright",
    opacity = 1,
    values = ag_land_sf$ag_proportion,
    pal = ag_pal,
    #labels = c('Not Undereserved', "Underserved"),
    title = HTML('Land in Ag'),
    group = "Ag_Proportion",
    className = "info legend Ag_Proportion",
    na.label = 'No data',
    labFormat = labelFormat(
      suffix = "%"
    )
    ) %>%
  addLayersControl(
    baseGroups = c(
      "Poverty",
      "RUC",
      "Rural_Underserved",
      "Ag_Proportion"
    ),
    options = layersControlOptions(collapsed = TRUE)
  ) %>%
  htmlwidgets::onRender(
      "
        function(el, x) {
           var updateLegend = function () {
              var mapContainer = el.closest('.leaflet-container');
              var selectedGroup = mapContainer.querySelectorAll('input:checked')[0].nextSibling.innerText.substr(1);

              mapContainer.querySelectorAll('.legend').forEach(a => a.hidden=true);
              mapContainer.querySelectorAll('.legend').forEach(l => {
                 if (l.classList.contains(selectedGroup)) l.hidden=false;
              });
           };
           updateLegend();
           this.on('baselayerchange', el => updateLegend());
        }"
    ) %>%
  bslib::card(full_screen = TRUE)

m

```

```{r combine all data for PCA}

comm_wealth <- comm_wealth_all %>%
  select(fips, year, variable_name, value) %>%
  group_by(fips, variable_name) %>%
  summarise(value = mean(value, na.rm = TRUE)) %>%
  ungroup() %>%
  pivot_wider(names_from = variable_name, values_from = value)

d <- comm_wealth %>%
  merge(ruc, by = 'fips') %>%
  merge(underserved, by = 'fips') %>%
  merge(pov, by = 'fips') %>%
  merge(ag_land, by = 'fips') %>%
  filter(!county_name %in% c('Menominee County', 'Kidder County'))

rownames(d) <- d$fips

# remove non-numeric variables and add them back after PCA
d_factors <- d %>%
  select_if(is.factor) 

d <- d %>% 
  select(-fips) %>% 
  select_if(is.numeric)

for(i in 1:ncol(d)){
  d[is.na(d[,i]), i] <- mean(d[,i], na.rm = TRUE)
}
```

### Analyzing the relationship between community characteristics and LAMP funding

The USDA aims to make LAMP grants available to all eligible communities across the US and its territories. To effectively distribute these grants, USDA considers various factors, such as potential for job creation, improvement in local food supply chains, and enhancement of local economies, with an intended focus on underserved communities and regions with limited market access.

With this in mind, the relationship between LAMP awards and community characteristics are evaluated in order to determine if there are gaps in the distribution of grant money across communities, and if such a gap is identified, what characteristics describe the communities within this gap. This information could help AMS determine what interventions may be necessary to fill these gaps.

#### Plotting each variable against total LAMP award money received

As a first step in assessing this relationship, each of the community characteristics described above are plotted against the total per capita LAMP funding received. Each point represents a county. The x axis of each plot is the value for variable described in the sub-plot header (e.g., "acres in conservation"), and the y axis is the total per capita LAMP funding.

##### Per capita LAMP grants received vs community characteristics

```{r prepping wealth vs award data}

# join lamp_by_county and individual `overall` scores
lamp_by_county2 <- lamp_by_county %>%
  st_drop_geometry()

clean_up <- function(d) {
  return (d %>%
          st_drop_geometry() %>%
          select(fips, overall))
}

pop_url <- 'https://www.ers.usda.gov/webdocs/DataFiles/48747/PopulationEstimates.csv?v=8269.9'

pop <- read.csv(pop_url) %>%
  filter(Attribute == 'CENSUS_2020_POP',
         FIPStxt != 0) %>%
  select(FIPStxt, Value) %>%
  rename(
    population_2020 = Value,
    fips = FIPStxt
    )

pop$fips <- sapply(pop$fips, add_leading_zero)

# clean up lamp data and add total county grant $ column before joining
d2 <- d %>%
  merge(d_factors, by = 0) %>%
  rename(fips = Row.names) %>%
  merge(lamp_by_county2, by = 'fips') %>%
  merge(pop, by = 'fips') %>%
  mutate(award_per_capita = Award.Amount / population_2020) %>%
  select(-population_2020)
```

```{r wealth vs award scatter plots}
#| fig-height: 15
#| fig-width: 10
#| fig-align: center
#| out-width: 100%

old_vars <- c(
  "acre_FSA", 
  "assn",
  "broad_16",
  "conserve_acre",
  "create_indus",
  "create_jobs",
  "ed_attain",
  "deposits",
  "est_CBP",
  "food_secure",
  "foodbev_est_CBP",
  "health_factors",
  "pc1b_manufacturing",
  "pc1f",
  "pc1c_artsdiversity",
  "pc1h_healtheducation",
  "pc1s_nonprofitsocialindustries",
  "pc1n_naturalamenitiesconservation",
  "pc2b_infrastructure",
  "pc2n_farmland",
  "pc2s_publicvoiceparticipation",
  "pc2c_creativeindustries",
  "pc2h_medicalfoodsecurity",
  "health_outcomes",
  "highway_km",
  "insured",
  "localgovfin",
  "museums",
  "natamen_scale",
  "nccs",
  "owner_occupied",
  "primary_care",
  "prime_farmland",
  "pub_lib",
  "pvote",
  "racial_div",
  "respn",
  "poverty_rate",
  "ag_proportion",
  "is_rural",
  "is_underserved",
  "RUCC_2023",
  "Award.Amount",
  "Acre_NFS"
  )

new_vars <- c(
  "Acres in conservation", 
  "Social establishments",
  "Broadband access",
  "Acres under easement",
  "Creative industry",
  "Jobs in the arts",
  "Education levels",
  "Band deposits",
  "County business patterns",
  "Food security",
  "Food & bev businesses",
  "Health factors",
  "pc1b_manufacturing",
  "pc1f",
  "pc1c_artsdiversity",
  "pc1h_healtheducation",
  "pc1s_nonprofitsocialindustries",
  "pc1n_naturalamenitiesconservation",
  "pc2b_infrastructure",
  "pc2n_farmland",
  "pc2s_publicvoiceparticipation",
  "pc2c_creativeindustries",
  "pc2h_medicalfoodsecurity",
  "Health outcomes",
  "Highways",
  "Insured rate",
  "Local gov finances",
  "Museum access",
  "Natural amenities",
  "Non-profits",
  "Home ownership",
  "Health care access",
  "Prime farmland",
  "Public libraries",
  "Voting rate",
  "Racial diversity",
  "Census response rate",
  "Poverty rate",
  "Ag land proportion",
  "Rural status",
  "Underserved status",
  "Rural continuum",
  "Total LAMP funding",
  "National forests"
  )

var_map <- bind_cols(old_vars, new_vars)
names(var_map) <- c("old_vars", "new_vars")

d3 <- d2 %>%
  drop_na() %>%
  filter(!county_name %in% c('Menominee County', 'Kidder County'))

id_vars <- c('fips', 'county_name', 'lamp_funded', 'award_per_capita')
measure_vars <- colnames(d2)[!colnames(d2) %in% id_vars]

d3 <- reshape2::melt(
  d3, id.vars = id_vars,
  measure.vars = measure_vars)

d3 <- d3 %>%
  merge(var_map, by.x = 'variable', by.y = 'old_vars') %>%
  select(-variable) %>%
  rename(variable = new_vars)

d3 <- d3 %>% mutate(value = as.numeric(value)) %>%
  filter(
    county_name != "Shannon County" & variable != "Non profits"
  )

# Create a scatter plot with facets
p <- ggplot(d3 %>% filter(variable != "Total LAMP funding") %>% ungroup(),
            aes(x = value,
                y = award_per_capita)) +
     geom_point(aes(color = variable#,
                #text = paste("County:", county_name)
                ),
                alpha = 0.4, size = 1.5) +
     geom_smooth(aes(color = variable, fill = variable), 
                 method = 'lm', fullrange = TRUE, linewidth = .4) +
     scale_color_manual(values = ggsci::pal_igv("default")(length(unique(d3$variable)))) +
     scale_fill_manual(values = ggsci::pal_igv("default")(length(unique(d3$variable)))) +
     facet_wrap(~ variable, ncol = 6, scales = 'free_x') +
     labs(title = 'Community Wealth Indices vs LAMP $ Per Capita, 2016-2022',
          y = 'Total Award $ Per Capita, 2016-2022',
          x = '',
          caption = "Note: two counties, Menominee County (Michigan) and Kidder County (North Dakota), were removed from the dataset used for this plot because they were identified as outliers."
          ) +
     #ylim(0, 1) +
     theme_minimal() +
     theme(
       legend.position = "none",
       strip.background = element_rect(fill="#2F414BFF"),
       strip.text = element_text(color = 'grey76', face = 'bold')
     )

p

#ggsave("myplot.png", plot = p, width = 6000, height = 3000, units = 'px')
```

### Principal Component Analysis (PCA)

Principal Component Analysis (PCA) is a technique used to reduce the dimensionality of multivariate data sets. It aims to simplify the data by reducing the number of variables into a smaller number of components, while still retaining as much variation from the original variables as possible, thereby allowing for a more concise expression of a larger set of variables.

In the context of this analysis, PCA is thought to be an appropriate approach because of the thematic overlap among groups of variables, implying that multicolinearity may be an issue. Indeed, a correlation matrix of all variables shows a number of highly correlated variables within the dataset.

##### Correlation matrix

```{r correlation pre-PCA}

d_corr <- d3 %>%
  distinct() %>%
  pivot_wider(names_from = variable, values_from = value)  %>%
  st_drop_geometry() %>%
  select(-c(fips, award_per_capita, lamp_funded, county_name)) 

correlation <- cor(d_corr, use = "complete.obs")
corrplot(correlation, method = 'square', tl.cex = 0.5, tl.col = 'black', tl.srt = 45,
         cl.cex = 0.6,
         type = 'upper', order = "hclust")

```

After disposing of all principal components with eigenvalues less than one, five principal components remained. The plots below show the main variables contributing to each of the 10 principal components.

##### Key variables contributing to each principal component

```{r principal components analysis}
#| fig-align: center
#| fig-width: 10
#| fig-height: 10

## PCA
res.pca <- prcomp(d, scale = TRUE)
#pca_summary <- summary(res.pca)

#fviz_eig(res.pca, col.var="blue", ncp = 25)

var <- get_pca_var(res.pca)
#corrplot(var$cos2, is.corr=FALSE)

eig_vals <- res.pca$sdev
k <- length(eig_vals[eig_vals >= 1])

# fviz_pca_var(res.pca,
#              col.var = "cos2", # Color by the quality of representation
#              gradient.cols = c("darkorchid4", "gold", "darkorange"),
#              repel = TRUE
#              )

# Contributions of variables to PCs 1 to 10
p1 <- fviz_contrib(res.pca, choice = "var", axes = 1, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) +
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p2 <- fviz_contrib(res.pca, choice = "var", axes = 2, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p3 <- fviz_contrib(res.pca, choice = "var", axes = 3, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 10,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p4 <- fviz_contrib(res.pca, choice = "var", axes = 4, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p5 <- fviz_contrib(res.pca, choice = "var", axes = 5, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p6 <- fviz_contrib(res.pca, choice = "var", axes = 6, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p7 <- fviz_contrib(res.pca, choice = "var", axes = 7, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p8 <- fviz_contrib(res.pca, choice = "var", axes = 8, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p9 <- fviz_contrib(res.pca, choice = "var", axes = 9, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
p10 <- fviz_contrib(res.pca, choice = "var", axes = 10, top = 10, sort.val = 'asc',
                   fill = "#FEB893", color = "transparent", linewidth = 5,
                   width = 0.4) + 
  theme_minimal() + coord_flip() +
  theme(axis.text.x = element_text(size=4),
        axis.title.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.title.y=element_blank(),
        axis.ticks.y=element_blank()
        )
ggarrange(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, 
          ncol=2, nrow=5, heights = c(100, 100),
          #font.label = list(size = 6, color = "black", face = "bold", family = 'Roboto'),
          align = 'hv',
          label.x = '', label.y = ''
)

eigenvectors <- res.pca$rotation
eigenvectors_keep <- eigenvectors[,1:k]
rotated_data <- data.frame(res.pca$x[,1:k])

#corr_matrix <- cor(rotated_data)
#ggcorrplot(corr_matrix)

#ggsave("pca_plot.png", plot = p, width = 6000, height = 3000, units = 'px')
```

#### Discussion of retained principal components

The ten retained principal components were renamed according to their contributing variables.

Names: "pc1_education""pc2_arts", "pc3_conservation1", "pc4_farmland1", "pc5_infrastructure", "pc6_farmland2", "pc7_manufacturing", "pc8_conservation2", "pc9_foodbev", "pc10_civics"

```{r rename principal component variables}

oldnames = colnames(rotated_data)
newnames = c("pc1_education", "pc2_arts", "pc3_conservation1", "pc4_farmland1",
             "pc5_infrastructure", "pc6_farmland2", "pc7_manufacturing",
             "pc8_conservation2", "pc9_foodbev", "pc10_civics")

reduced_d <- rotated_data %>% rename_at(vars(all_of(oldnames)), ~ newnames)
```

### Cluster analysis

Another approach to dealing with the large number of variables that may be related to LAMP grant funding is to use a clustering algorithm to find groups of counties that are similar across many variables.

The optimal number of clusters was determined using the "elbow method", which works by running k-means clustering using a range of K values (1:20 was used in this analysis), calculating the average score for each cluster, and plotting the mean distance. The optimal value of K is the point where the rate of decrease in distortion or inertia shifts, known as the "elbow".

##### "Elbow plot"

```{r cluster analysis}
#| fig-align: center
#| fig-width: 12
#| fig-height: 7
#| out-width: 70%

# df <- df %>% 
#   column_to_rownames(., var = "GEOID") %>%
#   drop_na()
# df <- sapply(df, as.numeric)

# standardization
df_scaled <- data.frame(scale(reduced_d, center = TRUE, scale = TRUE))

fviz_nbclust(df_scaled, kmeans, method = "wss", k.max = 20) +  
  geom_vline(xintercept = 11, linetype = 11)


# result <- NbClust(df_norm, distance = "euclidean",
#                   min.nc = 3, max.nc = 30, method = "kmeans",
#                   index = "kl")

# won't converge!
# n_clust <- n_clusters(df_scaled,
#                       package = c("easystats", "NbClust", "mclust"),
#                       standardize = TRUE,
#                       n_max = 20
#                       )
# print(n_clust)

km <- kmeans(df_scaled, centers = 11) # centers specify number of clusters
#km
#fviz_cluster(km, df_scaled, ggtheme = theme_minimal())

# print(result$All.index)
# # result$Best.nc
# # result$Best.partition
# membership <- result$Best.partition
# 
# add cluster membership vector to data set
clustered <- reduced_d %>%
  mutate(cluster = km$cluster) %>%
  merge(select(d2, c(fips, lamp_funded, Award.Amount, award_per_capita)),
        by.x = 0, by.y = 'fips') %>%
  select(-Row.names) %>%
  mutate(
    Award.Amount = ifelse(is.na(Award.Amount), 0, Award.Amount),
    award_per_capita = ifelse(is.na(award_per_capita), 0, award_per_capita),
    )
```

#### Cluster exploration

```{r kmeans summaries}
#| fig-align: center
#| fig-width: 10
#| fig-height: 35

within_ss <- km$withinss
cluster_size <- km$size

clustered_melted2 <- reshape2::melt(
  clustered, id.vars = c('cluster', 'lamp_funded'))

cdf <- clustered %>%
  group_by(cluster) %>%
  summarise_if(is.numeric, list(mean = mean, sd = sd), na.rm = TRUE)

cdf$count <- cluster_size
cdf$cluster <- factor(cdf$cluster, levels=c(11,10,9,8,7,6,5,4,3,2,1))

plot_creator <- function(pc_n) {
  
  var <- as.vector(
    unique(clustered_melted2$variable))[grep(paste0("pc", pc_n, "_"), as.vector(unique(clustered_melted2$variable)))]

  clustered_melted2 %>%
  mutate(cluster = factor(cluster, levels = c(11,10,9,8,7,6,5,4,3,2,1))) %>%
  filter(grepl(paste0("pc", pc_n, "_"), variable)) %>%
  ggplot(aes(x=cluster, y=value),
         shape = 21) +
  geom_jitter(aes(fill = factor(cluster), color = factor(cluster)),
              shape=21, size = 1, alpha = 0.6,
              color = 'transparent') +
  geom_boxplot(aes(group = cluster), fill = 'transparent',
               outlier.color = 'darkred', outlier.shape = 4) +
  coord_flip() +
  scale_fill_manual(
    values = as.vector(paletteer_d("rcartocolor::Prism"))[1:length(unique(clustered_melted2$cluster))]) +
  scale_colour_manual(
    values = as.vector(paletteer_d("rcartocolor::Prism"))[1:length(unique(clustered_melted2$cluster))]) +
  #theme_minimal() +
  # labs(title = var,
  #      #x ="Social Capital Cluster", 
  #      #y = "Social Capital Index",
  #      color = "") +
  xlab("cluster number") +
  theme(
    legend.position="none",
    #plot.title=element_text(family='Roboto', face='bold', size=20),
    plot.margin = margin(t = 50,  # Top margin
                         r = 0,  # Right margin
                         b = 0,  # Bottom margin
                         l = 0)
  )
}


table_creator <- function(pc_n) {
  mean_col <- colnames(cdf)[grepl(paste0("pc", pc_n, "_"), colnames(cdf))][1]
  sd_col <- colnames(cdf)[grepl(paste0("pc", pc_n, "_"), colnames(cdf))][2]
  c <- cdf %>%
    select(cluster, count, dplyr::starts_with(paste0("pc", pc_n, "_"))) %>%
    mutate(mean = round(!!sym(mean_col), 2),
           sd = round(!!sym(sd_col), 2)) %>%
    # rename(
    #   mean = !!sym(mean_col),
    #   sd = !!sym(sd_col)
    # ) %>%
    mutate(
      `mean (sd)` = paste0(as.character(mean), " (", as.character(sd), ")")
    ) %>%
    select(cluster, count, `mean (sd)`)
  
  # this left aligns the first column and right aligns the second and third columns
  core_hjust <- matrix(c(0, 1, 1), nrow = nrow(c), ncol = ncol(c), byrow = TRUE)
  core_x <- matrix(c(0.1, 0.9, 0.9), nrow = nrow(c), ncol = ncol(c), byrow = TRUE)

  colhead_hjust <- c(0, 1, 1)
  colhead_x <- c(0.1, 0.9, 0.9) 
    
  c <- tableGrob(
    c,
    theme=ttheme_minimal(
      base_size = 13,
      base_family = 'Roboto Mono',
      core = list(
        padding=unit(c(1, 5), "mm"),
        fg_params = list(
          hjust = as.vector(core_hjust),
          x = as.vector(core_x),
          fontsize = 12)
        ),
      colhead = list(
        fg_params = list(
        hjust = colhead_hjust, 
        x = colhead_x, 
        fontsize = 16, 
        fontface = 2))
    ), 
    rows=NULL
    )
}

t1 <- table_creator(1)
p1 <- plot_creator(1)
t2 <- table_creator(2)
p2 <- plot_creator(2)
t3 <- table_creator(3)
p3 <- plot_creator(3)
t4 <- table_creator(4)
p4 <- plot_creator(4)
t5 <- table_creator(5)
p5 <- plot_creator(5)
t6 <- table_creator(6)
p6 <- plot_creator(6)
t7 <- table_creator(7)
p7 <- plot_creator(7)
t8 <- table_creator(8)
p8 <- plot_creator(8)
t9 <- table_creator(9)
p9 <- plot_creator(9)
t10 <- table_creator(10)
p10 <- plot_creator(10)

plot_design <- 
  "
  AB
  "
```

::: {#plot_header style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #1 - Education
:::

```{r education plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p1, t1, design = plot_design, heights = c(8,200))

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #2 - Arts
:::

```{r arts plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p2, t2, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #3 - Conservation1
:::

```{r conservation1 plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p3, t3, design = plot_design)


```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #4 - Farmland1
:::

```{r farmland1 plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p4, t4, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #5 - Infrastructure
:::

```{r infrastructure plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p5, t5, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #6 - Farmland2
:::

```{r farmland2 plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p6, t6, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #7 - Manufacturing
:::

```{r manufacturing plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p7, t7, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #8 - Conservation2
:::

```{r conservation2 plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p8, t8, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #9 - Food and Beverage
:::

```{r food and bev plot}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p9, t9, design = plot_design)

```

::: {style="background-color:#bbc5c6; font-weight: 600; font-family: system-ui;"}
Principal Component #10 - Civics
:::

```{r arts civis}
#| fig-align: center
#| fig-width: 10
#| fig-height: 5

wrap_plots(p10, t10, design = plot_design)

```

### Regression analysis

Regression analysis is a statistical technique that is used to estimate the effect of one or more explanatory variables on a dependent variable. In this case, regression can be used to evaluate the relationship between each of the community characteristic variables (the explanatory variables) and the LAMP funding amounts (the dependent variable) at the county level.

While each of the original original 44 community characteristic variables could be included in the regression model as explanatory variables, this analysis opts to use only the ten principal components. These components capture much of the variance of the original variables, while allowing for a simpler model that is easier to interpret.

#### Linear regression using per capita LAMP funding

For this analysis, a linear regression could be used to look at the relationship between community characteristics and the total amount of LAMP funding per county. This approach provides estimates on the relationship between each explanatory variable and the actual dollar amount going to each county.

##### Z-test of coefficients - linear regression

```{r linear regression}

# Use dataset with all og data plus factors and lamp grant data
d_reg_pc <- reduced_d %>%
  merge(d_factors, by = 0) %>%
  rename(fips = Row.names) %>%
  merge(lamp_by_county2, by = 'fips') %>%
  merge(pop, by = 'fips') %>%
  mutate(award_per_capita = Award.Amount / population_2020) %>%
  select(-c(population_2020, county_name)) %>%
  mutate(
    Award.Amount = ifelse(is.na(Award.Amount), 0, Award.Amount),
    award_per_capita = ifelse(is.na(award_per_capita), 0, award_per_capita)
  )

# start with just a few variables as predictors
predictors <- names(d_reg_pc)[!names(d_reg_pc) %in% c('fips', 'lamp_funded', 'Award.Amount', 'award_per_capita')]

# Prepare the model formula
deny_lm <- glm(paste("Award.Amount ~", paste(predictors, collapse = " + ")),
                  data = d_reg_pc)

model_2_coef <- coeftest(deny_lm, vcov. = vcovHC, type = "HC1")
model_2_coef_df <- as.data.frame(model_2_coef[,]) %>% 
  mutate_if(is.numeric, round, digits = 2) %>%
  mutate(sig = ifelse(`Pr(>|z|)` <= .001, "***",
                      ifelse(`Pr(>|z|)` <= .01, "**",
                             ifelse(`Pr(>|z|)` <= .05, "*", "")
                             )
                      ),
         `Pr(>|z|)` = as.character(`Pr(>|z|)`),
         `Pr(>|z|)` = paste0(`Pr(>|z|)`, sig)
  ) %>%
  select(-sig)

gt_tbl <- model_2_coef_df |>
  rownames_to_column() %>%
  gt() %>%
  # tab_header(
  #   title = "Indicators of community wealth variables",
  #   subtitle = "Descriptions and sources of data used in analysis"
  # ) |>
  # tab_source_note(
  #   source_note = "Source: The World Almanac and Book of Facts, 1975, page 406."
  # ) |>
  # tab_source_note(
  #   source_note = md("Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.")
  # ) |>
  tab_footnote(
    footnote = "Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"#,
    # locations = cells_body(
    #   columns = size, rows = largest
    # )
  ) |>
  tab_options(row.striping.include_table_body = FALSE) |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(
    font = google_font("Roboto")) |>
  tab_options(
    table.font.size = 12
  ) |>
  tab_options(quarto.disable_processing = TRUE)

gt_tbl
```

#### Logistic regression using binary funded/not funded

Alternatively, a logistic regression could be used to focus on whether or not a given county received any LAMP funding at all. This approach provides estimates on the relationship between each explanatory variable and the probability of a given county receiving any LAMP funding at all.

```{r regression analysis all vars}

# # Use dataset with all og data plus factors and lamp grant data
# d_reg <- d %>%
#   merge(d_factors, by = 0) %>%
#   rename(fips = Row.names) %>%
#   merge(lamp_by_county2, by = 'fips') %>%
#   merge(pop, by = 'fips') %>%
#   mutate(award_per_capita = Award.Amount / population_2020) %>%
#   select(-c(population_2020, county_name)) %>%
#   mutate(
#     Award.Amount = ifelse(is.na(Award.Amount), 0, Award.Amount),
#     award_per_capita = ifelse(is.na(award_per_capita), 0, award_per_capita)
#   )
# 
# # start with just a few variables as predictors
# predictors <- names(d_reg)[!names(d_reg) %in% c('fips', 'lamp_funded', 'Award.Amount', 'award_per_capita')]
# 
# # Prepare the model formula
# denyprobit <- glm(paste("lamp_funded ~", paste(predictors, collapse = " + ")),
#                   family = binomial(link = "probit"),
#                   data = d_reg)
# 
# coeftest(denyprobit, vcov. = vcovHC, type = "HC1")
# 
# denylogit <- glm(paste("lamp_funded ~", paste(predictors, collapse = " + ")),
#                  family = binomial(link = "logit"),
#                  data = d_reg)
# 
# coeftest(denylogit, vcov. = vcovHC, type = "HC1")
```

##### Z-test of coefficients - logistic regression

```{r logit and probit regression pcs}

# Use dataset with all og data plus factors and lamp grant data
d_reg_pc <- reduced_d %>%
  merge(d_factors, by = 0) %>%
  rename(fips = Row.names) %>%
  merge(lamp_by_county2, by = 'fips') %>%
  merge(pop, by = 'fips') %>%
  mutate(award_per_capita = Award.Amount / population_2020) %>%
  select(-c(population_2020, county_name)) %>%
  mutate(
    Award.Amount = ifelse(is.na(Award.Amount), 0, Award.Amount),
    award_per_capita = ifelse(is.na(award_per_capita), 0, award_per_capita)
  )

# start with just a few variables as predictors
predictors <- names(d_reg_pc)[!names(d_reg_pc) %in% c('fips', 'lamp_funded', 'Award.Amount', 'award_per_capita')]

# Prepare the model formula
# denyprobit <- glm(paste("lamp_funded ~", paste(predictors, collapse = " + ")),
#                   family = binomial(link = "probit"),
#                   data = d_reg_pc)
# 
# coeftest(denyprobit, vcov. = vcovHC, type = "HC1")

denylogit <- glm(paste("lamp_funded ~", paste(predictors, collapse = " + ")),
                 family = binomial(link = "logit"),
                 data = d_reg_pc)

model_1_coef <- coeftest(denylogit, vcov. = vcovHC, type = "HC1")
model_1_coef_df <- as.data.frame(model_1_coef[,]) %>% 
  mutate_if(is.numeric, round, digits = 2) %>%
  mutate(sig = ifelse(`Pr(>|z|)` <= .001, "***",
                      ifelse(`Pr(>|z|)` <= .01, "**",
                             ifelse(`Pr(>|z|)` <= .05, "*", "")
                             )
                      ),
         `Pr(>|z|)` = as.character(`Pr(>|z|)`),
         `Pr(>|z|)` = paste0(`Pr(>|z|)`, sig)
  ) %>%
  select(-sig)

gt_tbl <- model_1_coef_df |>
  rownames_to_column() %>%
  gt() %>%
  # tab_header(
  #   title = "Indicators of community wealth variables",
  #   subtitle = "Descriptions and sources of data used in analysis"
  # ) |>
  # tab_source_note(
  #   source_note = "Source: The World Almanac and Book of Facts, 1975, page 406."
  # ) |>
  # tab_source_note(
  #   source_note = md("Reference: McNeil, D. R. (1977) *Interactive Data Analysis*. Wiley.")
  # ) |>
  tab_footnote(
    footnote = "Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1"#,
    # locations = cells_body(
    #   columns = size, rows = largest
    # )
  ) |>
  tab_options(row.striping.include_table_body = FALSE) |>
  opt_row_striping(row_striping = FALSE) |>
  opt_table_font(
    font = google_font("Roboto")) |>
  tab_options(
    table.font.size = 12
  ) |>
  tab_options(quarto.disable_processing = TRUE)

gt_tbl

```

##### 

### Discussion

This report provides an initial analysis of community characteristics influencing the allocation of LAMP grant funding. Through methods such as Principal Component Analysis and clustering, it identifies key factors and patterns that may affect grant distribution. The findings highlight potential barriers and suggest that certain community attributes, like educational levels and infrastructure, play significant roles in grant success. These insights can guide policy recommendations to ensure more equitable access to LAMP resources, ultimately fostering stronger local and regional food systems across diverse communities.

### **Next Steps and Future Research**

1.  **Expand Data Sources**: Incorporate additional datasets, such as local economic indicators and community resilience metrics, to provide a more holistic view of factors influencing LAMP funding allocation.

2.  **Longitudinal Studies**: Conduct longitudinal studies to track changes in community characteristics over time and their impact on LAMP funding success. This can help identify long-term trends and effects of previous funding.

3.  **Qualitative Research**: Complement quantitative analysis with qualitative research, such as interviews and focus groups, to capture the nuanced experiences and challenges faced by communities in accessing LAMP grants.

4.  **Policy Evaluation**: Evaluate the effectiveness of current LAMP policies and outreach programs. This can involve assessing whether targeted interventions are reducing barriers for socially disadvantaged communities.

5.  **Geospatial Analysis**: Use advanced geospatial analysis to identify spatial patterns and clusters of grant allocation, focusing on underserved regions that may benefit from targeted support.

6.  **Collaboration and Partnerships**: Encourage collaboration between academic institutions, government agencies, and community organizations to share data, insights, and best practices, enhancing the overall impact of LAMP programs.

7.  **Impact Assessment**: Develop metrics to assess the socio-economic impact of LAMP funding on local food systems, including job creation, business growth, and community well-being, to better understand and communicate the program's benefits.
